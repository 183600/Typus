-- The actual implementation would be more complex

module Compiler (compile) where

import Parser (TypusFile(..), CodeBlock(..), FileDirectives(..), BlockDirectives(..))
import qualified Ownership (analyzeOwnership)
import Data.List (intercalate, isInfixOf, isPrefixOf)
import Data.Char (isSpace)

-- Compile function that takes a TypusFile and generates Go code
compile :: TypusFile -> Either String String
compile typusFile = 
  -- Check for malformed syntax (very basic check)
  if hasMalformedSyntax typusFile
    then Left "Malformed syntax detected"
    -- Check for type errors (very basic check)
    else if hasTypeErrors typusFile
      then Left "Type errors detected"
      -- Check for ownership errors
      else case checkOwnership typusFile of
        Left err -> Left err
        Right _ -> Right $ generateGoCode typusFile

-- Check for ownership errors (TEMPORARILY DISABLED)
checkOwnership :: TypusFile -> Either String ()
checkOwnership typusFile = 
  -- TODO: Fix ownership analysis - currently causing infinite loops
  -- For now, skip ownership check
  Right ()

-- Basic syntax checks
hasMalformedSyntax :: TypusFile -> Bool
hasMalformedSyntax typusFile = 
  let content = intercalate "\n" $ map cbContent (tfBlocks typusFile)
  in null content || "malformed" `isInfixOf` content

-- Basic type checks
hasTypeErrors :: TypusFile -> Bool
hasTypeErrors typusFile = 
  let content = intercalate "\n" $ map cbContent (tfBlocks typusFile)
  in "type error" `isInfixOf` content

-- Generate source code (placeholder)
generateSourceCode :: TypusFile -> String
generateSourceCode typusFile = 
  let
    -- Generate file directives
    fileDirectives = generateFileDirectives (tfDirectives typusFile)
    
    -- Generate code blocks
    blocks = generateCodeBlocks (tfBlocks typusFile)
    
    -- Combine all parts
    allParts = filter (not . null) [fileDirectives, blocks]
  in
    intercalate "\n" allParts

-- Generate file directives
generateFileDirectives :: FileDirectives -> String
generateFileDirectives dirs = 
  let
    ownershipLine = case fdOwnership dirs of
      Just True -> "//! ownership: on"
      Just False -> "//! ownership: off"
      Nothing -> ""
    dependentTypesLine = case fdDependentTypes dirs of
      Just True -> "//! dependent_types: on"
      Just False -> "//! dependent_types: off"
      Nothing -> ""
    constraintsLine = case fdConstraints dirs of
      Just True -> "//! constraints: on"
      Just False -> "//! constraints: off"
      Nothing -> ""
    directiveLines = filter (not . null) [ownershipLine, dependentTypesLine, constraintsLine]
  in
    intercalate "\n" directiveLines

-- Generate code blocks as source code
generateCodeBlocks :: [CodeBlock] -> String
generateCodeBlocks blocks = 
  intercalate "\\n" (map cbContent blocks)

-- Generate Go code from TypusFile
generateGoCode :: TypusFile -> String
generateGoCode typusFile = 
  let
    -- Generate file header (only once)
    header = "package main\n"
    
    -- Generate imports (only once)
    imports = generateImports typusFile
    
    -- Generate code blocks with all necessary transformations
    blocks = transformCodeBlocks (tfBlocks typusFile)
    
    -- Check for dependent types directive and add runtime support if needed
    runtimeSupport = if hasDependentTypesDirective typusFile 
                      then generateRuntimeSupport
                      else ""
    
    -- Remove duplicate package declarations and imports from code blocks
    cleanedBlocks = cleanCodeBlocks blocks
    
    -- Combine all parts
    allParts = filter (not . null) [header, imports, runtimeSupport, cleanedBlocks]
  in
    intercalate "\n" allParts ++ "\n"

-- Check if file has dependent types directive
hasDependentTypesDirective :: TypusFile -> Bool
hasDependentTypesDirective typusFile = 
  case fdDependentTypes (tfDirectives typusFile) of
    Just True -> True
    _ -> any (\block -> bdDependentTypes (cbDirectives block)) (tfBlocks typusFile)

-- Generate imports section
generateImports :: TypusFile -> String
generateImports typusFile = 
  let
    content = intercalate "\n" $ map cbContent (tfBlocks typusFile)
    hasFmt = "fmt." `isInfixOf` content || "fmt\n" `isInfixOf` content || "\"fmt\"" `isInfixOf` content
    hasMath = "math." `isInfixOf` content || "\"math\"" `isInfixOf` content
    hasTime = "time." `isInfixOf` content || "\"time\"" `isInfixOf` content
    hasOs = "os." `isInfixOf` content || "\"os\"" `isInfixOf` content
    hasIo = "io." `isInfixOf` content || "\"io\"" `isInfixOf` content
    hasStrings = "strings." `isInfixOf` content || "\"strings\"" `isInfixOf` content
    hasSync = "sync." `isInfixOf` content || "\"sync\"" `isInfixOf` content
    hasRuntime = "runtime." `isInfixOf` content || "\"runtime\"" `isInfixOf` content
    hasUnsafe = "unsafe." `isInfixOf` content || "\"unsafe\"" `isInfixOf` content
    imports = filter (not . null) [
        if hasFmt then "    \"fmt\"" else "",
        if hasMath then "    \"math\"" else "",
        if hasTime then "    \"time\"" else "",
        if hasOs then "    \"os\"" else "",
        if hasIo then "    \"io\"" else "",
        if hasStrings then "    \"strings\"" else "",
        if hasSync then "    \"sync\"" else "",
        if hasRuntime then "    \"runtime\"" else "",
        if hasUnsafe then "    \"unsafe\"" else ""
      ]
  in
    if null imports 
      then ""
      else "import (\n" ++ intercalate "\n" imports ++ "\n)"

-- Transform code blocks with all necessary fixes
transformCodeBlocks :: [CodeBlock] -> String
transformCodeBlocks blocks = 
  let
    blockContents = map cbContent blocks
    -- Filter out EOF lines
    filteredContents = map filterEOF (filter (not . null) blockContents)
    -- Apply all transformations
    transformedContents = map transformCode filteredContents
  in
    intercalate "\n" transformedContents

-- Filter out EOF lines
filterEOF :: String -> String
filterEOF content = 
  unlines $ filter (not . isEOFLine) (lines content)
  where
    isEOFLine line = "EOF < /dev/null" `isInfixOf` line

-- Transform code to fix syntax issues
transformCode :: String -> String
transformCode content = 
  let
    linesContent = lines content
    transformedLines = map transformLine linesContent
  in
    unlines transformedLines

-- Transform a line to fix syntax issues
transformLine :: String -> String
transformLine line =
  -- Fix dependent types syntax
  if "type " `isInfixOf` line && " where " `isInfixOf` line
    then
      let
        -- Extract type name (before <)
        typeName = takeWhile (/= '<') (drop 5 line)  -- drop "type "
        -- Extract constraint
        constraint = extractConstraint line
        -- Create simplified type declaration with constraint as comment
        simplified = "type " ++ typeName ++ " struct {  // Constraint: " ++ constraint
      in
        simplified
    else
      line

-- Extract constraint from dependent type declaration
extractConstraint :: String -> String
extractConstraint line =
  case break (== 'w') (dropWhile (/= 'w') line) of  -- Find "where"
    (_, 'w':'h':'e':'r':'e':' ':constraint) -> 
      takeWhile (\c -> c /= '{' && c /= '\n') (trim constraint)
    _ -> "unknown constraint"

-- Generate runtime support for dependent types
generateRuntimeSupport :: String
generateRuntimeSupport = 
  "// Dependent types runtime support\n" ++
  "/*\n" ++
  " * Note: Dependent types are not natively supported in Go.\n" ++
  " * Runtime checks would be needed to enforce constraints.\n" ++
  " * Example functions for constraint validation would go here.\n" ++
  " */\n"

-- Clean code blocks by removing duplicate package declarations and imports
cleanCodeBlocks :: String -> String
cleanCodeBlocks content = 
  let
    linesList = lines content
    -- Remove lines that start with "package main" or "import" 
    -- as these are already handled by the header and imports generation
    -- Also remove lines that are just import statements (like "fmt" or "sync")
    -- Also remove lines that are just quoted import statements (like "\"fmt\"")
    filteredLines = filter (\line -> 
        not (isPrefixOf "package main" line) && 
        not (isPrefixOf "import" line) &&
        not (isImportLine line)) linesList
  in
    unlines filteredLines
  where
    -- Check if a line is just an import statement (like "fmt" or "sync")
    isImportLine line = 
      let trimmed = trim line
      in (trimmed == "fmt" || trimmed == "sync" || trimmed == "time" || 
          trimmed == "unsafe" || trimmed == "os" || trimmed == "io" || 
          trimmed == "strings" || trimmed == "math" || trimmed == "runtime" ||
          trimmed == "\"fmt\"" || trimmed == "\"sync\"" || trimmed == "\"time\"" || 
          trimmed == "\"unsafe\"" || trimmed == "\"os\"" || trimmed == "\"io\"" || 
          trimmed == "\"strings\"" || trimmed == "\"math\"" || trimmed == "\"runtime\"")
    
    -- Check if a line is just a closing parenthesis

-- Utility function to trim whitespace
trim :: String -> String
trim = f . f
  where f = reverse . dropWhile isSpace