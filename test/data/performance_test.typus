package main

// 性能压力测试文件

import (
    "fmt"
    "math"
    "runtime"
    "sync"
    "time"
)

func main() {
    fmt.Println("Starting performance tests...")
    fmt.Printf("NumCPU: %d, GOMAXPROCS: %d\n", runtime.NumCPU(), runtime.GOMAXPROCS(0))
    
    // 测试1: 大规模数据处理
    largeDataProcessing()
    
    // 测试2: 复杂算法性能
    complexAlgorithmPerformance()
    
    // 测试3: 并发性能测试
    concurrencyPerformance()
    
    // 测试4: 内存分配压力测试
    memoryAllocationStress()
    
    // 测试5: 递归性能测试
    recursionPerformance()
    
    // 测试6: 字符串操作性能
    stringOperationPerformance()
    
    // 测试7: Map操作性能
    mapOperationPerformance()
    
    // 测试8: 通道通信性能
    channelCommunicationPerformance()
    
    // 测试9: 接口调用性能
    interfaceCallPerformance()
    
    // 测试10: 反射性能测试
    reflectionPerformance()
    
    fmt.Println("Performance tests completed")
}

func largeDataProcessing() {
    fmt.Println("\n=== Large Data Processing Test ===")
    
    start := time.Now()
    
    // 创建大规模数据集
    size := 10000000 // 1000万
    data := make([]int, size)
    
    // 初始化数据
    for i := 0; i < size; i++ {
        data[i] = i * i
    }
    
    // 数据处理
    sum := 0
    for _, v := range data {
        sum += v
    }
    
    // 复杂计算
    result := float64(sum) / float64(size)
    stdDev := calculateStdDev(data)
    
    elapsed := time.Since(start)
    
    fmt.Printf("Data size: %d\n", size)
    fmt.Printf("Average: %.2f\n", result)
    fmt.Printf("StdDev: %.2f\n", stdDev)
    fmt.Printf("Processing time: %v\n", elapsed)
    fmt.Printf("Memory usage: %d KB\n", getMemoryUsage())
}

func calculateStdDev(data []int) float64 {
    if len(data) == 0 {
        return 0
    }
    
    // 计算平均值
    sum := 0
    for _, v := range data {
        sum += v
    }
    mean := float64(sum) / float64(len(data))
    
    // 计算标准差
    varianceSum := 0.0
    for _, v := range data {
        diff := float64(v) - mean
        varianceSum += diff * diff
    }
    
    return math.Sqrt(varianceSum / float64(len(data)))
}

func complexAlgorithmPerformance() {
    fmt.Println("\n=== Complex Algorithm Performance ===")
    
    algorithms := []struct {
        name string
        fn   func(int) int
    }{
        {"Fibonacci", fibonacci},
        {"Factorial", factorial},
        {"Prime Count", countPrimes},
        {"Matrix Operations", matrixOperations},
    }
    
    inputSize := 30
    
    for _, algo := range algorithms {
        start := time.Now()
        result := algo.fn(inputSize)
        elapsed := time.Since(start)
        
        fmt.Printf("%s(%d) = %d, Time: %v\n", algo.name, inputSize, result, elapsed)
    }
}

func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    return fibonacci(n-1) + fibonacci(n-2)
}

func factorial(n int) int {
    if n <= 1 {
        return 1
    }
    return n * factorial(n-1)
}

func countPrimes(n int) int {
    count := 0
    for i := 2; i <= n; i++ {
        if isPrime(i) {
            count++
        }
    }
    return count
}

func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n%2 == 0 || n%3 == 0 {
        return false
    }
    for i := 5; i*i <= n; i += 6 {
        if n%i == 0 || n%(i+2) == 0 {
            return false
        }
    }
    return true
}

func matrixOperations(n int) int {
    // 创建n x n矩阵
    matrix := make([][]int, n)
    for i := range matrix {
        matrix[i] = make([]int, n)
        for j := range matrix[i] {
            matrix[i][j] = i*j + i + j
        }
    }
    
    // 矩阵乘法
    result := 0
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            sum := 0
            for k := 0; k < n; k++ {
                sum += matrix[i][k] * matrix[k][j]
            }
            result += sum
        }
    }
    
    return result
}

func concurrencyPerformance() {
    fmt.Println("\n=== Concurrency Performance ===")
    
    workerCounts := []int{1, 2, 4, 8, 16, 32}
    taskCount := 10000
    
    for _, workers := range workerCounts {
        start := time.Now()
        
        jobs := make(chan int, taskCount)
        results := make(chan int, taskCount)
        
        // 启动worker
        var wg sync.WaitGroup
        for w := 0; w < workers; w++ {
            wg.Add(1)
            go worker(w, jobs, results, &wg)
        }
        
        // 发送任务
        for j := 0; j < taskCount; j++ {
            jobs <- j
        }
        close(jobs)
        
        // 等待所有worker完成
        wg.Wait()
        close(results)
        
        // 收集结果
        sum := 0
        for r := range results {
            sum += r
        }
        
        elapsed := time.Since(start)
        fmt.Printf("Workers: %d, Tasks: %d, Time: %v, Throughput: %.2f tasks/sec\n", 
            workers, taskCount, elapsed, float64(taskCount)/elapsed.Seconds())
    }
}

func worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {
    defer wg.Done()
    for j := range jobs {
        // 模拟一些工作
        result := j * j
        results <- result
    }
}

func memoryAllocationStress() {
    fmt.Println("\n=== Memory Allocation Stress ===")
    
    sizes := []int{1000, 10000, 100000, 1000000}
    
    for _, size := range sizes {
        start := time.Now()
        
        // 分配大量内存
        data := make([][]int, size)
        for i := range data {
            data[i] = make([]int, 100) // 每行100个整数
            for j := range data[i] {
                data[i][j] = i*j
            }
        }
        
        // 强制垃圾回收
        runtime.GC()
        
        elapsed := time.Since(start)
        memoryUsage := getMemoryUsage()
        
        fmt.Printf("Size: %d, Time: %v, Memory: %d KB\n", size, elapsed, memoryUsage)
        
        // 释放内存
        data = nil
        runtime.GC()
    }
}

func recursionPerformance() {
    fmt.Println("\n=== Recursion Performance ===")
    
    depths := []int{10, 50, 100, 500, 1000, 5000}
    
    for _, depth := range depths {
        start := time.Now()
        
        result := recursiveSum(depth)
        
        elapsed := time.Since(start)
        fmt.Printf("Depth: %d, Result: %d, Time: %v\n", depth, result, elapsed)
    }
}

func recursiveSum(n int) int {
    if n <= 0 {
        return 0
    }
    return n + recursiveSum(n-1)
}

func stringOperationPerformance() {
    fmt.Println("\n=== String Operation Performance ===")
    
    sizes := []int{100, 1000, 10000, 100000}
    
    for _, size := range sizes {
        start := time.Now()
        
        // 字符串拼接
        var result string
        for i := 0; i < size; i++ {
            result += "x"
        }
        
        elapsed := time.Since(start)
        fmt.Printf("String concat size: %d, Time: %v, Length: %d\n", size, elapsed, len(result))
    }
    
    // 字符串处理
    largeString := ""
    for i := 0; i < 10000; i++ {
        largeString += fmt.Sprintf("word%d ", i)
    }
    
    start := time.Now()
    words := strings.Split(largeString, " ")
    wordCount := len(words)
    elapsed := time.Since(start)
    
    fmt.Printf("String split: %d words, Time: %v\n", wordCount, elapsed)
}

func mapOperationPerformance() {
    fmt.Println("\n=== Map Operation Performance ===")
    
    sizes := []int{1000, 10000, 100000}
    
    for _, size := range sizes {
        start := time.Now()
        
        // 创建map
        m := make(map[int]string)
        
        // 插入
        for i := 0; i < size; i++ {
            m[i] = fmt.Sprintf("value%d", i)
        }
        
        // 查找
        found := 0
        for i := 0; i < size; i++ {
            if _, ok := m[i]; ok {
                found++
            }
        }
        
        // 删除
        for i := 0; i < size/2; i++ {
            delete(m, i)
        }
        
        elapsed := time.Since(start)
        fmt.Printf("Map size: %d, Operations: %d, Time: %v\n", size, size*2, elapsed)
    }
}

func channelCommunicationPerformance() {
    fmt.Println("\n=== Channel Communication Performance ===")
    
    messageCounts := []int{1000, 10000, 100000}
    
    for _, count := range messageCounts {
        start := time.Now()
        
        ch := make(chan int, count)
        
        // 发送者
        go func() {
            for i := 0; i < count; i++ {
                ch <- i
            }
            close(ch)
        }()
        
        // 接收者
        received := 0
        for range ch {
            received++
        }
        
        elapsed := time.Since(start)
        fmt.Printf("Messages: %d, Time: %v, Throughput: %.2f msg/sec\n", 
            count, elapsed, float64(count)/elapsed.Seconds())
    }
}

func interfaceCallPerformance() {
    fmt.Println("\n=== Interface Call Performance ===")
    
    type Calculator interface {
        Add(a, b int) int
        Multiply(a, b int) int
    }
    
    type BasicCalc struct{}
    
    func (c BasicCalc) Add(a, b int) int {
        return a + b
    }
    
    func (c BasicCalc) Multiply(a, b int) int {
        return a * b
    }
    
    calc := BasicCalc{}
    var calcInterface Calculator = calc
    
    iterations := 1000000
    
    // 直接调用
    start := time.Now()
    for i := 0; i < iterations; i++ {
        _ = calc.Add(i, i+1)
    }
    directTime := time.Since(start)
    
    // 接口调用
    start = time.Now()
    for i := 0; i < iterations; i++ {
        _ = calcInterface.Add(i, i+1)
    }
    interfaceTime := time.Since(start)
    
    fmt.Printf("Direct calls: %v, Interface calls: %v, Overhead: %.2f%%\n", 
        directTime, interfaceTime, float64(interfaceTime-directTime)/float64(directTime)*100)
}

func reflectionPerformance() {
    fmt.Println("\n=== Reflection Performance ===")
    
    type Person struct {
        Name string
        Age  int
    }
    
    p := Person{Name: "John", Age: 30}
    
    iterations := 100000
    
    // 直接访问
    start := time.Now()
    for i := 0; i < iterations; i++ {
        _ = p.Name
        _ = p.Age
    }
    directTime := time.Since(start)
    
    // 反射访问
    start = time.Now()
    for i := 0; i < iterations; i++ {
        v := reflect.ValueOf(p)
        _ = v.FieldByName("Name").String()
        _ = v.FieldByName("Age").Int()
    }
    reflectTime := time.Since(start)
    
    fmt.Printf("Direct access: %v, Reflection access: %v, Overhead: %.2fx\n", 
        directTime, reflectTime, float64(reflectTime)/float64(directTime))
}

func getMemoryUsage() int {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    return int(m.Alloc / 1024) // KB
}