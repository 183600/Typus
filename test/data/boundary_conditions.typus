package main

// è¾¹ç•Œæ¡ä»¶æµ‹è¯•æ–‡ä»¶
import "fmt"
import "math"

func main() {
    // æ•´æ•°è¾¹ç•Œæµ‹è¯•
    maxInt64 := int64(9223372036854775807)
    minInt64 := int64(-9223372036854775808)
    maxUint64 := uint64(18446744073709551615)
    
    println("Max int64:", maxInt64)
    println("Min int64:", minInt64)
    println("Max uint64:", maxUint64)
    
    // æµ®ç‚¹æ•°è¾¹ç•Œæµ‹è¯•
    maxFloat64 := math.MaxFloat64
    minFloat64 := math.SmallestNonzeroFloat64
    inf := math.Inf(1)
    negInf := math.Inf(-1)
    nan := math.NaN()
    
    println("Max float64:", maxFloat64)
    println("Min float64:", minFloat64)
    println("Positive infinity:", inf)
    println("Negative infinity:", negInf)
    println("NaN:", nan)
    
    // å­—ç¬¦ä¸²è¾¹ç•Œæµ‹è¯•
    emptyString := ""
    singleChar := "a"
    unicodeString := "Hello, ä¸–ç•Œ! ğŸŒ"
    veryLongString := ""
    
    // åˆ›å»ºä¸€ä¸ªå¾ˆé•¿çš„å­—ç¬¦ä¸²
    for i := 0; i < 1000; i++ {
        veryLongString += "x"
    }
    
    println("Empty string length:", len(emptyString))
    println("Single char:", singleChar)
    println("Unicode string:", unicodeString)
    println("Very long string length:", len(veryLongString))
    
    // æ•°ç»„è¾¹ç•Œæµ‹è¯•
    emptyArray := []int{}
    singleElement := []int{42}
    largeArray := make([]int, 1000000)
    
    println("Empty array length:", len(emptyArray))
    println("Single element:", singleElement[0])
    println("Large array length:", len(largeArray))
    
    // Mapè¾¹ç•Œæµ‹è¯•
    emptyMap := make(map[string]int)
    singleMap := map[string]int{"key": 1}
    largeMap := make(map[string]int)
    
    for i := 0; i < 10000; i++ {
        largeMap[fmt.Sprintf("key%d", i)] = i
    }
    
    println("Empty map length:", len(emptyMap))
    println("Single map value:", singleMap["key"])
    println("Large map length:", len(largeMap))
    
    // é€’å½’æ·±åº¦æµ‹è¯•
    deepRecursion(1000)
    
    // å¾ªç¯è¾¹ç•Œæµ‹è¯•
    zeroIterations := 0
    for i := 0; i < zeroIterations; i++ {
        println("This should not print")
    }
    
    oneIteration := 1
    for i := 0; i < oneIteration; i++ {
        println("Single iteration:", i)
    }
    
    // é€šé“è¾¹ç•Œæµ‹è¯•
    unbufferedChan := make(chan int)
    bufferedChan := make(chan int, 1000)
    
    go func() {
        unbufferedChan <- 42
    }()
    
    bufferedChan <- 1
    bufferedChan <- 2
    
    println("Unbuffered channel:", <-unbufferedChan)
    println("Buffered channel values:", <-bufferedChan, <-bufferedChan)
    
    // æŒ‡é’ˆè¾¹ç•Œæµ‹è¯•
    nilPointer := (*int)(nil)
    validPointer := new(int)
    *validPointer = 100
    
    if nilPointer == nil {
        println("Nil pointer detected")
    }
    println("Valid pointer value:", *validPointer)
}

func deepRecursion(depth int) {
    if depth <= 0 {
        println("Reached recursion depth limit")
        return
    }
    if depth%100 == 0 {
        println("Recursion depth:", depth)
    }
    deepRecursion(depth - 1)
}