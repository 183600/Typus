<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>-- Simplified Typus to Go Compiler
<span class="lineno">    2 </span>
<span class="lineno">    3 </span>module Compiler (compile, hasTypeErrors, extractDeclarations, extractFunctionCalls, buildTypeEnv, isMethodDeclaration, checkTypeError, hasMalformedSyntax, checkDependentTypes, checkOwnership, generateGoCode) where
<span class="lineno">    4 </span>
<span class="lineno">    5 </span>import Parser (TypusFile(..), CodeBlock(..), FileDirectives(..), BlockDirectives(..))
<span class="lineno">    6 </span>import DependentTypesParser (DependentTypeError(..), runDependentTypesParser, parserErrors)
<span class="lineno">    7 </span>import Ownership (analyzeOwnership, formatOwnershipErrors)
<span class="lineno">    8 </span>import Data.List (intercalate, isInfixOf, isPrefixOf)
<span class="lineno">    9 </span>import Data.Char (isSpace)
<span class="lineno">   10 </span>
<span class="lineno">   11 </span>-- Compile function that takes a TypusFile and generates Go code
<span class="lineno">   12 </span>compile :: TypusFile -&gt; Either String String
<span class="lineno">   13 </span><span class="decl"><span class="istickedoff">compile typusFile =</span>
<span class="lineno">   14 </span><span class="spaces">  </span><span class="istickedoff">-- Check for malformed syntax (very basic check)</span>
<span class="lineno">   15 </span><span class="spaces">  </span><span class="istickedoff">if hasMalformedSyntax typusFile</span>
<span class="lineno">   16 </span><span class="spaces">    </span><span class="istickedoff">then Left <span class="nottickedoff">&quot;Malformed syntax detected&quot;</span></span>
<span class="lineno">   17 </span><span class="spaces">    </span><span class="istickedoff">-- Check for dependent types errors if enabled</span>
<span class="lineno">   18 </span><span class="spaces">    </span><span class="istickedoff">else case checkDependentTypes typusFile of</span>
<span class="lineno">   19 </span><span class="spaces">      </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">Left err</span></span>
<span class="lineno">   20 </span><span class="spaces">      </span><span class="istickedoff">Right _ -&gt;</span>
<span class="lineno">   21 </span><span class="spaces">        </span><span class="istickedoff">-- Check for basic type errors (very basic check)</span>
<span class="lineno">   22 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasTypeErrors <span class="nottickedoff">typusFile</span></span></span>
<span class="lineno">   23 </span><span class="spaces">          </span><span class="istickedoff">then <span class="nottickedoff">Left &quot;Type errors detected&quot;</span></span>
<span class="lineno">   24 </span><span class="spaces">          </span><span class="istickedoff">-- Check for ownership errors</span>
<span class="lineno">   25 </span><span class="spaces">          </span><span class="istickedoff">else case checkOwnership typusFile of</span>
<span class="lineno">   26 </span><span class="spaces">            </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">Left err</span></span>
<span class="lineno">   27 </span><span class="spaces">            </span><span class="istickedoff">Right _ -&gt; Right $ generateGoCode typusFile</span></span>
<span class="lineno">   28 </span>
<span class="lineno">   29 </span>-- Check for dependent types errors
<span class="lineno">   30 </span>checkDependentTypes :: TypusFile -&gt; Either String ()
<span class="lineno">   31 </span><span class="decl"><span class="istickedoff">checkDependentTypes typusFile =</span>
<span class="lineno">   32 </span><span class="spaces">  </span><span class="istickedoff">-- Check if dependent types are enabled at file or block level</span>
<span class="lineno">   33 </span><span class="spaces">  </span><span class="istickedoff">let fileEnabled = case fdDependentTypes (tfDirectives typusFile) of</span>
<span class="lineno">   34 </span><span class="spaces">        </span><span class="istickedoff">Just True -&gt; True</span>
<span class="lineno">   35 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; False</span>
<span class="lineno">   36 </span><span class="spaces">      </span><span class="istickedoff">blockEnabled = any (\block -&gt; bdDependentTypes (cbDirectives block)) (tfBlocks typusFile)</span>
<span class="lineno">   37 </span><span class="spaces">      </span><span class="istickedoff">shouldCheck = fileEnabled || blockEnabled</span>
<span class="lineno">   38 </span><span class="spaces">  </span><span class="istickedoff">in if shouldCheck</span>
<span class="lineno">   39 </span><span class="spaces">     </span><span class="istickedoff">then case extractDependentTypeContent typusFile of</span>
<span class="lineno">   40 </span><span class="spaces">       </span><span class="istickedoff">[] -&gt; Right <span class="nottickedoff">()</span>  -- No dependent type content to check</span>
<span class="lineno">   41 </span><span class="spaces">       </span><span class="istickedoff">content -&gt;</span>
<span class="lineno">   42 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">case runDependentTypesParser content of</span></span>
<span class="lineno">   43 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">Left err -&gt; Left $ &quot;Dependent type parsing error: &quot; ++ err</span></span>
<span class="lineno">   44 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">Right (_, parser) -&gt;</span></span>
<span class="lineno">   45 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">let errors = parserErrors parser</span></span>
<span class="lineno">   46 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">in if null errors</span></span>
<span class="lineno">   47 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">then Right ()</span></span>
<span class="lineno">   48 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">else Left $ &quot;Dependent type errors: &quot; ++ formatDependentTypeErrors errors</span></span>
<span class="lineno">   49 </span><span class="spaces">     </span><span class="istickedoff">else Right <span class="nottickedoff">()</span></span></span>
<span class="lineno">   50 </span>
<span class="lineno">   51 </span>-- Extract dependent type content from TypusFile
<span class="lineno">   52 </span>extractDependentTypeContent :: TypusFile -&gt; String
<span class="lineno">   53 </span><span class="decl"><span class="istickedoff">extractDependentTypeContent typusFile =</span>
<span class="lineno">   54 </span><span class="spaces">  </span><span class="istickedoff">let dependentBlocks = filter (\block -&gt; bdDependentTypes (cbDirectives block)) (tfBlocks typusFile)</span>
<span class="lineno">   55 </span><span class="spaces">  </span><span class="istickedoff">in concatMap <span class="nottickedoff">cbContent</span> dependentBlocks</span></span>
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>-- Extract ownership content from TypusFile
<span class="lineno">   58 </span>extractOwnershipContent :: TypusFile -&gt; String
<span class="lineno">   59 </span><span class="decl"><span class="istickedoff">extractOwnershipContent typusFile =</span>
<span class="lineno">   60 </span><span class="spaces">  </span><span class="istickedoff">let ownershipBlocks = filter (\block -&gt; bdOwnership (cbDirectives block)) (tfBlocks typusFile)</span>
<span class="lineno">   61 </span><span class="spaces">  </span><span class="istickedoff">in concatMap <span class="nottickedoff">cbContent</span> ownershipBlocks</span></span>
<span class="lineno">   62 </span>
<span class="lineno">   63 </span>-- Format dependent type errors for display
<span class="lineno">   64 </span>formatDependentTypeErrors :: [DependentTypeError] -&gt; String
<span class="lineno">   65 </span><span class="decl"><span class="nottickedoff">formatDependentTypeErrors = intercalate &quot;; &quot; . map formatError</span>
<span class="lineno">   66 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">   67 </span><span class="spaces">    </span><span class="nottickedoff">formatError (SyntaxError msg line snippet) =</span>
<span class="lineno">   68 </span><span class="spaces">      </span><span class="nottickedoff">&quot;Syntax error at line &quot; ++ show line ++ &quot;: &quot; ++ msg ++ &quot; (&quot; ++ snippet ++ &quot;)&quot;</span>
<span class="lineno">   69 </span><span class="spaces">    </span><span class="nottickedoff">formatError (InvalidTypeSyntax msg) = &quot;Invalid type syntax: &quot; ++ msg</span>
<span class="lineno">   70 </span><span class="spaces">    </span><span class="nottickedoff">formatError (MissingConstraint msg) = &quot;Missing constraint: &quot; ++ msg</span>
<span class="lineno">   71 </span><span class="spaces">    </span><span class="nottickedoff">formatError (InvalidParameter msg) = &quot;Invalid parameter: &quot; ++ msg</span>
<span class="lineno">   72 </span><span class="spaces">    </span><span class="nottickedoff">formatError (ConstraintParseError msg) = &quot;Constraint parse error: &quot; ++ msg</span>
<span class="lineno">   73 </span><span class="spaces">    </span><span class="nottickedoff">formatError (TypeVariableError msg) = &quot;Type variable error: &quot; ++ msg</span></span>
<span class="lineno">   74 </span>
<span class="lineno">   75 </span>
<span class="lineno">   76 </span>-- Check for ownership errors
<span class="lineno">   77 </span>checkOwnership :: TypusFile -&gt; Either String ()
<span class="lineno">   78 </span><span class="decl"><span class="istickedoff">checkOwnership typusFile =</span>
<span class="lineno">   79 </span><span class="spaces">  </span><span class="istickedoff">-- Check if ownership is enabled at file or block level</span>
<span class="lineno">   80 </span><span class="spaces">  </span><span class="istickedoff">let fileEnabled = case fdOwnership (tfDirectives typusFile) of</span>
<span class="lineno">   81 </span><span class="spaces">        </span><span class="istickedoff">Just True -&gt; True</span>
<span class="lineno">   82 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; False</span>
<span class="lineno">   83 </span><span class="spaces">      </span><span class="istickedoff">blockEnabled = any (\block -&gt; bdOwnership (cbDirectives block)) (tfBlocks typusFile)</span>
<span class="lineno">   84 </span><span class="spaces">      </span><span class="istickedoff">shouldCheck = fileEnabled || blockEnabled</span>
<span class="lineno">   85 </span><span class="spaces">  </span><span class="istickedoff">in if shouldCheck</span>
<span class="lineno">   86 </span><span class="spaces">     </span><span class="istickedoff">then case extractOwnershipContent typusFile of</span>
<span class="lineno">   87 </span><span class="spaces">       </span><span class="istickedoff">&quot;&quot; -&gt; Right <span class="nottickedoff">()</span>  -- No ownership content to check</span>
<span class="lineno">   88 </span><span class="spaces">       </span><span class="istickedoff">content -&gt;</span>
<span class="lineno">   89 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">let errors = analyzeOwnership content</span></span>
<span class="lineno">   90 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">in if null errors</span></span>
<span class="lineno">   91 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">then Right ()</span></span>
<span class="lineno">   92 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">else Left $ &quot;Ownership errors: &quot; ++ formatOwnershipErrors errors</span></span>
<span class="lineno">   93 </span><span class="spaces">     </span><span class="istickedoff">else Right <span class="nottickedoff">()</span></span></span>
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>-- Basic syntax checks
<span class="lineno">   96 </span>hasMalformedSyntax :: TypusFile -&gt; Bool
<span class="lineno">   97 </span><span class="decl"><span class="istickedoff">hasMalformedSyntax typusFile = </span>
<span class="lineno">   98 </span><span class="spaces">  </span><span class="istickedoff">let content = intercalate <span class="nottickedoff">&quot;\n&quot;</span> $ map cbContent (tfBlocks typusFile)</span>
<span class="lineno">   99 </span><span class="spaces">  </span><span class="istickedoff">in null content || &quot;malformed&quot; `isInfixOf` content</span></span>
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>-- Basic type data types
<span class="lineno">  102 </span>data Type = IntType | StringType | BoolType | FloatType | VoidType | FunctionType [Type] Type
<span class="lineno">  103 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  104 </span>
<span class="lineno">  105 </span>data TypeEnv = TypeEnv {
<span class="lineno">  106 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">varTypes</span></span></span> :: [(String, Type)],
<span class="lineno">  107 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">functionTypes</span></span></span> :: [(String, ([Type], Type))]
<span class="lineno">  108 </span>} deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  109 </span>
<span class="lineno">  110 </span>emptyTypeEnv :: TypeEnv
<span class="lineno">  111 </span><span class="decl"><span class="nottickedoff">emptyTypeEnv = TypeEnv [] []</span></span>
<span class="lineno">  112 </span>
<span class="lineno">  113 </span>-- Basic type checks
<span class="lineno">  114 </span>hasTypeErrors :: TypusFile -&gt; Bool
<span class="lineno">  115 </span><span class="decl"><span class="istickedoff">hasTypeErrors _typusFile = False</span></span> -- any (checkTypeError env) (nonMethodDecls ++ calls) -- Temporarily disabled
<span class="lineno">  116 </span>
<span class="lineno">  117 </span>-- Check if a line is a method declaration (has a receiver)
<span class="lineno">  118 </span>isMethodDeclaration :: String -&gt; Bool
<span class="lineno">  119 </span><span class="decl"><span class="nottickedoff">isMethodDeclaration line =</span>
<span class="lineno">  120 </span><span class="spaces">  </span><span class="nottickedoff">let t = trim line</span>
<span class="lineno">  121 </span><span class="spaces">  </span><span class="nottickedoff">in isPrefixOf &quot;func (&quot; t</span></span>
<span class="lineno">  122 </span>
<span class="lineno">  123 </span>-- Check if a line is a function call
<span class="lineno">  124 </span>isFunctionCall :: String -&gt; Bool
<span class="lineno">  125 </span><span class="decl"><span class="nottickedoff">isFunctionCall line =</span>
<span class="lineno">  126 </span><span class="spaces">  </span><span class="nottickedoff">let t = trim line</span>
<span class="lineno">  127 </span><span class="spaces">  </span><span class="nottickedoff">in &quot;(&quot; `isInfixOf` t &amp;&amp; &quot;)&quot; `isInfixOf` t &amp;&amp; not (isPrefixOf &quot;func&quot; t) &amp;&amp; not (isPrefixOf &quot;var &quot; t) &amp;&amp; not (isPrefixOf &quot;const &quot; t)</span></span>
<span class="lineno">  128 </span>
<span class="lineno">  129 </span>-- Generate Go code from TypusFile
<span class="lineno">  130 </span>generateGoCode :: TypusFile -&gt; String
<span class="lineno">  131 </span><span class="decl"><span class="istickedoff">generateGoCode typusFile =</span>
<span class="lineno">  132 </span><span class="spaces">  </span><span class="istickedoff">let</span>
<span class="lineno">  133 </span><span class="spaces">    </span><span class="istickedoff">header = &quot;package main\n&quot;</span>
<span class="lineno">  134 </span><span class="spaces">    </span><span class="istickedoff">imports = generateImports typusFile</span>
<span class="lineno">  135 </span><span class="spaces">    </span><span class="istickedoff">originalContentRaw = intercalate <span class="nottickedoff">&quot;\n&quot;</span> $ map cbContent (tfBlocks typusFile)</span>
<span class="lineno">  136 </span><span class="spaces">    </span><span class="istickedoff">originalContent = enforceGoStructure $ fixUnusedS2 $ fixVarBlocks $ cleanCodeBlocks originalContentRaw</span>
<span class="lineno">  137 </span><span class="spaces">    </span><span class="istickedoff">allParts = filter (not . null) [header, imports, originalContent]</span>
<span class="lineno">  138 </span><span class="spaces">  </span><span class="istickedoff">in intercalate &quot;\n&quot; allParts</span></span>
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>-- Simple clean - just remove package and import lines
<span class="lineno">  141 </span>cleanCodeBlocks :: String -&gt; String
<span class="lineno">  142 </span><span class="decl"><span class="istickedoff">cleanCodeBlocks content =</span>
<span class="lineno">  143 </span><span class="spaces">  </span><span class="istickedoff">let ls = lines content</span>
<span class="lineno">  144 </span><span class="spaces">      </span><span class="istickedoff">goRemoveImports [] _ acc = reverse acc</span>
<span class="lineno">  145 </span><span class="spaces">      </span><span class="istickedoff">goRemoveImports (l:rest) inImport acc =</span>
<span class="lineno">  146 </span><span class="spaces">        </span><span class="istickedoff">let t = trim l</span>
<span class="lineno">  147 </span><span class="spaces">        </span><span class="istickedoff">in if inImport</span>
<span class="lineno">  148 </span><span class="spaces">             </span><span class="istickedoff">then if t == &quot;)&quot; then goRemoveImports rest False acc</span>
<span class="lineno">  149 </span><span class="spaces">                  </span><span class="istickedoff">else goRemoveImports rest True acc</span>
<span class="lineno">  150 </span><span class="spaces">             </span><span class="istickedoff">else if isPrefixOf &quot;package&quot; t</span>
<span class="lineno">  151 </span><span class="spaces">                    </span><span class="istickedoff">then goRemoveImports rest False acc</span>
<span class="lineno">  152 </span><span class="spaces">                    </span><span class="istickedoff">else if isPrefixOf &quot;import&quot; t</span>
<span class="lineno">  153 </span><span class="spaces">                           </span><span class="istickedoff">then if &quot;(&quot; `isInfixOf` t</span>
<span class="lineno">  154 </span><span class="spaces">                                   </span><span class="istickedoff">then goRemoveImports rest True acc</span>
<span class="lineno">  155 </span><span class="spaces">                                   </span><span class="istickedoff">else goRemoveImports rest False acc</span>
<span class="lineno">  156 </span><span class="spaces">                           </span><span class="istickedoff">else goRemoveImports rest False (l:acc)</span>
<span class="lineno">  157 </span><span class="spaces">  </span><span class="istickedoff">in unlines (goRemoveImports ls False [])</span></span>
<span class="lineno">  158 </span>
<span class="lineno">  159 </span>-- Generate imports section with enhanced detection
<span class="lineno">  160 </span>generateImports :: TypusFile -&gt; String
<span class="lineno">  161 </span><span class="decl"><span class="istickedoff">generateImports typusFile =</span>
<span class="lineno">  162 </span><span class="spaces">  </span><span class="istickedoff">let</span>
<span class="lineno">  163 </span><span class="spaces">    </span><span class="istickedoff">content = intercalate <span class="nottickedoff">&quot;\n&quot;</span> $ map cbContent (tfBlocks typusFile)</span>
<span class="lineno">  164 </span><span class="spaces">    </span><span class="istickedoff">processedContent = fixUnusedS2 $ fixVarBlocks $ cleanCodeBlocks content  -- Process content like the final code will be</span>
<span class="lineno">  165 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno">  166 </span><span class="spaces">    </span><span class="istickedoff">-- Enhanced import detection - detect usage in processed content</span>
<span class="lineno">  167 </span><span class="spaces">    </span><span class="istickedoff">hasTesting = &quot;*testing.T&quot; `isInfixOf` processedContent || &quot;*testing.B&quot; `isInfixOf` processedContent || &quot;func Test&quot; `isInfixOf` processedContent || &quot;func Benchmark&quot; `isInfixOf` processedContent || &quot;testing.&quot; `isInfixOf` processedContent</span>
<span class="lineno">  168 </span><span class="spaces">    </span><span class="istickedoff">hasBufio = &quot;bufio.&quot; `isInfixOf` processedContent</span>
<span class="lineno">  169 </span><span class="spaces">    </span><span class="istickedoff">hasFmt = &quot;fmt.&quot; `isInfixOf` processedContent || <span class="nottickedoff">&quot;fmt.Println&quot; `isInfixOf` processedContent || &quot;fmt.Printf&quot; `isInfixOf` processedContent</span></span>
<span class="lineno">  170 </span><span class="spaces">    </span><span class="istickedoff">hasMath = &quot;math.&quot; `isInfixOf` processedContent || &quot;math.Pi&quot; `isInfixOf` processedContent || &quot;math.Sqrt&quot; `isInfixOf` processedContent</span>
<span class="lineno">  171 </span><span class="spaces">    </span><span class="istickedoff">hasMathRand = (&quot;math/rand&quot; `isInfixOf` processedContent || &quot;rand.Seed&quot; `isInfixOf` processedContent || &quot;rand.Intn&quot; `isInfixOf` processedContent) &amp;&amp; <span class="nottickedoff">not (&quot;crypto/rand&quot; `isInfixOf` processedContent)</span></span>
<span class="lineno">  172 </span><span class="spaces">    </span><span class="istickedoff">hasCmplx = &quot;cmplx.&quot; `isInfixOf` processedContent || &quot;cmplx.Sqrt&quot; `isInfixOf` processedContent</span>
<span class="lineno">  173 </span><span class="spaces">    </span><span class="istickedoff">hasMathBig = &quot;big.&quot; `isInfixOf` processedContent || &quot;big.NewInt&quot; `isInfixOf` processedContent || &quot;big.Int&quot; `isInfixOf` processedContent</span>
<span class="lineno">  174 </span><span class="spaces">    </span><span class="istickedoff">hasTime = &quot;time.&quot; `isInfixOf` processedContent || &quot;time.Now&quot; `isInfixOf` processedContent || &quot;time.Sleep&quot; `isInfixOf` processedContent</span>
<span class="lineno">  175 </span><span class="spaces">    </span><span class="istickedoff">hasOs = &quot;os.&quot; `isInfixOf` processedContent || &quot;os.Create&quot; `isInfixOf` processedContent || &quot;os.ReadFile&quot; `isInfixOf` processedContent</span>
<span class="lineno">  176 </span><span class="spaces">    </span><span class="istickedoff">hasPathFilepath = &quot;filepath.&quot; `isInfixOf` processedContent || &quot;filepath.Join&quot; `isInfixOf` processedContent</span>
<span class="lineno">  177 </span><span class="spaces">    </span><span class="istickedoff">hasIo = (&quot; io.&quot; `isInfixOf` processedContent &amp;&amp; <span class="nottickedoff">not (&quot;bufio&quot; `isInfixOf` processedContent)</span>) || &quot;io.Copy(&quot; `isInfixOf` processedContent || &quot;io.Reader&quot; `isInfixOf` processedContent || &quot;io.Writer&quot; `isInfixOf` processedContent || &quot;io.ReadFull(&quot; `isInfixOf` processedContent</span>
<span class="lineno">  178 </span><span class="spaces">    </span><span class="istickedoff">hasIoUtil = &quot;ioutil.&quot; `isInfixOf` processedContent || &quot;ioutil.ReadFile&quot; `isInfixOf` processedContent || &quot;ioutil.WriteFile&quot; `isInfixOf` processedContent || &quot;ioutil.ReadAll&quot; `isInfixOf` processedContent</span>
<span class="lineno">  179 </span><span class="spaces">    </span><span class="istickedoff">hasStrings = &quot;strings.&quot; `isInfixOf` processedContent || &quot;strings.Split&quot; `isInfixOf` processedContent || &quot;strings.ToUpper&quot; `isInfixOf` processedContent</span>
<span class="lineno">  180 </span><span class="spaces">    </span><span class="istickedoff">hasSync = &quot;sync.&quot; `isInfixOf` processedContent || &quot;sync.Mutex&quot; `isInfixOf` processedContent || &quot;sync.WaitGroup&quot; `isInfixOf` processedContent</span>
<span class="lineno">  181 </span><span class="spaces">    </span><span class="istickedoff">hasSyncAtomic = &quot;atomic.&quot; `isInfixOf` processedContent || &quot;atomic.AddInt64&quot; `isInfixOf` processedContent || &quot;atomic.Bool&quot; `isInfixOf` processedContent</span>
<span class="lineno">  182 </span><span class="spaces">    </span><span class="istickedoff">hasRuntime = &quot;runtime.&quot; `isInfixOf` processedContent || &quot;runtime.GOOS&quot; `isInfixOf` processedContent</span>
<span class="lineno">  183 </span><span class="spaces">    </span><span class="istickedoff">hasUnsafe = &quot;unsafe.&quot; `isInfixOf` processedContent</span>
<span class="lineno">  184 </span><span class="spaces">    </span><span class="istickedoff">hasContainerList = &quot;container/list&quot; `isInfixOf` processedContent || &quot;list.New&quot; `isInfixOf` processedContent</span>
<span class="lineno">  185 </span><span class="spaces">    </span><span class="istickedoff">hasUnicodeUtf8 = &quot;unicode/utf8&quot; `isInfixOf` processedContent || &quot;utf8.RuneCountInString&quot; `isInfixOf` processedContent</span>
<span class="lineno">  186 </span><span class="spaces">    </span><span class="istickedoff">hasContext = &quot;context.&quot; `isInfixOf` processedContent &amp;&amp; <span class="nottickedoff">not (&quot;context :=&quot; `isInfixOf` processedContent) &amp;&amp; not (&quot;context :=&quot; `isInfixOf` processedContent) &amp;&amp; not (&quot;&amp;context&quot; `isInfixOf` processedContent)</span></span>
<span class="lineno">  187 </span><span class="spaces">    </span><span class="istickedoff">hasLog = &quot;log.&quot; `isInfixOf` processedContent</span>
<span class="lineno">  188 </span><span class="spaces">    </span><span class="istickedoff">hasReflect = &quot;reflect.&quot; `isInfixOf` processedContent || &quot;reflect.TypeOf&quot; `isInfixOf` processedContent || &quot;reflect.ValueOf&quot; `isInfixOf` processedContent</span>
<span class="lineno">  189 </span><span class="spaces">    </span><span class="istickedoff">hasStrconv = &quot;strconv.&quot; `isInfixOf` processedContent || &quot;strconv.Itoa&quot; `isInfixOf` processedContent || &quot;strconv.Atoi&quot; `isInfixOf` processedContent</span>
<span class="lineno">  190 </span><span class="spaces">    </span><span class="istickedoff">hasJson = &quot;json.&quot; `isInfixOf` processedContent || &quot;json.Marshal&quot; `isInfixOf` processedContent || &quot;json.Unmarshal&quot; `isInfixOf` processedContent</span>
<span class="lineno">  191 </span><span class="spaces">    </span><span class="istickedoff">hasXml = &quot;xml.&quot; `isInfixOf` processedContent || &quot;xml.Marshal&quot; `isInfixOf` processedContent</span>
<span class="lineno">  192 </span><span class="spaces">    </span><span class="istickedoff">hasRegexp = &quot;regexp.&quot; `isInfixOf` processedContent || &quot;regexp.MatchString&quot; `isInfixOf` processedContent || &quot;regexp.MustCompile&quot; `isInfixOf` processedContent</span>
<span class="lineno">  193 </span><span class="spaces">    </span><span class="istickedoff">hasErrors = &quot;errors.&quot; `isInfixOf` processedContent || &quot;errors.New&quot; `isInfixOf` processedContent</span>
<span class="lineno">  194 </span><span class="spaces">    </span><span class="istickedoff">hasHttp = &quot;http.&quot; `isInfixOf` processedContent || &quot;http.HandleFunc&quot; `isInfixOf` processedContent || &quot;http.ListenAndServe&quot; `isInfixOf` processedContent</span>
<span class="lineno">  195 </span><span class="spaces">    </span><span class="istickedoff">hasNetUrl = &quot;url.&quot; `isInfixOf` processedContent || &quot;url.Parse&quot; `isInfixOf` processedContent</span>
<span class="lineno">  196 </span><span class="spaces">    </span><span class="istickedoff">hasSort = &quot;sort.&quot; `isInfixOf` processedContent || &quot;sort.Ints&quot; `isInfixOf` processedContent || &quot;sort.Strings&quot; `isInfixOf` processedContent</span>
<span class="lineno">  197 </span><span class="spaces">    </span><span class="istickedoff">hasMd5 = &quot;md5.&quot; `isInfixOf` processedContent || &quot;md5.Sum&quot; `isInfixOf` processedContent || &quot;md5.New&quot; `isInfixOf` processedContent</span>
<span class="lineno">  198 </span><span class="spaces">    </span><span class="istickedoff">hasBytes = &quot;bytes.&quot; `isInfixOf` processedContent || &quot;bytes.Buffer&quot; `isInfixOf` processedContent</span>
<span class="lineno">  199 </span><span class="spaces">    </span><span class="istickedoff">hasGzip = &quot;gzip.&quot; `isInfixOf` processedContent || &quot;gzip.NewWriter&quot; `isInfixOf` processedContent || &quot;gzip.NewReader&quot; `isInfixOf` processedContent</span>
<span class="lineno">  200 </span><span class="spaces">    </span><span class="istickedoff">hasRing = &quot;ring.&quot; `isInfixOf` processedContent || &quot;ring.New&quot; `isInfixOf` processedContent</span>
<span class="lineno">  201 </span><span class="spaces">    </span><span class="istickedoff">hasBinary = &quot;binary.&quot; `isInfixOf` processedContent || &quot;binary.Write&quot; `isInfixOf` processedContent || &quot;binary.Read&quot; `isInfixOf` processedContent</span>
<span class="lineno">  202 </span><span class="spaces">    </span><span class="istickedoff">hasBits = &quot;bits.&quot; `isInfixOf` processedContent || &quot;bits.LeadingZeros&quot; `isInfixOf` processedContent</span>
<span class="lineno">  203 </span><span class="spaces">    </span><span class="istickedoff">hasFnv = &quot;fnv.&quot; `isInfixOf` processedContent || &quot;fnv.New32&quot; `isInfixOf` processedContent || &quot;fnv.New64&quot; `isInfixOf` processedContent</span>
<span class="lineno">  204 </span><span class="spaces">    </span><span class="istickedoff">hasNet = &quot;net.&quot; `isInfixOf` processedContent || &quot;net.Dial&quot; `isInfixOf` processedContent || &quot;net.Listen&quot; `isInfixOf` processedContent</span>
<span class="lineno">  205 </span><span class="spaces">    </span><span class="istickedoff">hasSyscall = &quot;syscall.&quot; `isInfixOf` processedContent || &quot;syscall.ForkExec&quot; `isInfixOf` processedContent || &quot;syscall.Kill&quot; `isInfixOf` processedContent</span>
<span class="lineno">  206 </span><span class="spaces">    </span><span class="istickedoff">hasSha1 = &quot;sha1.&quot; `isInfixOf` processedContent || &quot;sha1.Sum&quot; `isInfixOf` processedContent || &quot;sha1.New&quot; `isInfixOf` processedContent</span>
<span class="lineno">  207 </span><span class="spaces">    </span><span class="istickedoff">hasSha256 = &quot;sha256.&quot; `isInfixOf` processedContent || &quot;sha256.Sum&quot; `isInfixOf` processedContent || &quot;sha256.New&quot; `isInfixOf` processedContent</span>
<span class="lineno">  208 </span><span class="spaces">    </span><span class="istickedoff">hasSha512 = &quot;sha512.&quot; `isInfixOf` processedContent || &quot;sha512.Sum&quot; `isInfixOf` processedContent || &quot;sha512.New&quot; `isInfixOf` processedContent</span>
<span class="lineno">  209 </span><span class="spaces">    </span><span class="istickedoff">hasCrypto = &quot;crypto/aes&quot; `isInfixOf` processedContent || &quot;crypto/cipher&quot; `isInfixOf` processedContent || &quot;aes.NewCipher&quot; `isInfixOf` processedContent || &quot;cipher.NewCFBEncrypter&quot; `isInfixOf` processedContent</span>
<span class="lineno">  210 </span><span class="spaces">    </span><span class="istickedoff">hasCryptoRand = &quot;crypto/rand&quot; `isInfixOf` processedContent || &quot;rand.Reader&quot; `isInfixOf` processedContent</span>
<span class="lineno">  211 </span><span class="spaces">    </span><span class="istickedoff">hasBase64 = &quot;base64.&quot; `isInfixOf` processedContent || &quot;base64.StdEncoding&quot; `isInfixOf` processedContent</span>
<span class="lineno">  212 </span><span class="spaces">    </span><span class="istickedoff">hasHex = &quot;hex.&quot; `isInfixOf` processedContent || &quot;hex.EncodeToString&quot; `isInfixOf` processedContent || &quot;hex.DecodeString&quot; `isInfixOf` processedContent</span>
<span class="lineno">  213 </span><span class="spaces">    </span><span class="istickedoff">hasCsv = &quot;csv.&quot; `isInfixOf` processedContent || &quot;csv.NewReader&quot; `isInfixOf` processedContent</span>
<span class="lineno">  214 </span><span class="spaces">    </span><span class="istickedoff">hasDatabaseSql = &quot;database/sql&quot; `isInfixOf` processedContent || &quot;sql.DB&quot; `isInfixOf` processedContent || &quot;sql.Open&quot; `isInfixOf` processedContent || &quot;sql.Query&quot; `isInfixOf` processedContent || &quot;sql.Exec&quot; `isInfixOf` processedContent || &quot;_ \&quot;github.com/mattn/go-sqlite3\&quot;&quot; `isInfixOf` processedContent</span>
<span class="lineno">  215 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  216 </span><span class="spaces">    </span><span class="istickedoff">imports = filter (not . null) [</span>
<span class="lineno">  217 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasBufio</span> then <span class="nottickedoff">&quot;    \&quot;bufio\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  218 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasContainerList</span> then <span class="nottickedoff">&quot;    \&quot;container/list\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  219 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasContext</span> then <span class="nottickedoff">&quot;    \&quot;context\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  220 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasLog</span> then <span class="nottickedoff">&quot;    \&quot;log\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  221 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasReflect</span> then <span class="nottickedoff">&quot;    \&quot;reflect\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  222 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlytrue">hasFmt</span> then &quot;    \&quot;fmt\&quot;&quot; else <span class="nottickedoff">&quot;&quot;</span>,</span>
<span class="lineno">  223 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasMath</span> then <span class="nottickedoff">&quot;    \&quot;math\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  224 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasMathRand</span> then <span class="nottickedoff">&quot;    \&quot;math/rand\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  225 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasCmplx</span> then <span class="nottickedoff">&quot;    \&quot;math/cmplx\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  226 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasMathBig</span> then <span class="nottickedoff">&quot;    \&quot;math/big\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  227 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasTime</span> then <span class="nottickedoff">&quot;    \&quot;time\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  228 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasOs</span> then <span class="nottickedoff">&quot;    \&quot;os\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  229 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasPathFilepath</span> then <span class="nottickedoff">&quot;    \&quot;path/filepath\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  230 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasIo</span> then <span class="nottickedoff">&quot;    \&quot;io\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  231 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasIoUtil</span> then <span class="nottickedoff">&quot;    \&quot;io/ioutil\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  232 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasStrings</span> then <span class="nottickedoff">&quot;    \&quot;strings\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  233 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasSync</span> then <span class="nottickedoff">&quot;    \&quot;sync\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  234 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasSyncAtomic</span> then <span class="nottickedoff">&quot;    \&quot;sync/atomic\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  235 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasRuntime</span> then <span class="nottickedoff">&quot;    \&quot;runtime\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  236 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasUnicodeUtf8</span> then <span class="nottickedoff">&quot;    \&quot;unicode/utf8\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  237 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasUnsafe</span> then <span class="nottickedoff">&quot;    \&quot;unsafe\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  238 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasStrconv</span> then <span class="nottickedoff">&quot;    \&quot;strconv\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  239 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasJson</span> then <span class="nottickedoff">&quot;    \&quot;encoding/json\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  240 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasXml</span> then <span class="nottickedoff">&quot;    \&quot;encoding/xml\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  241 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasRegexp</span> then <span class="nottickedoff">&quot;    \&quot;regexp\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  242 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasErrors</span> then <span class="nottickedoff">&quot;    \&quot;errors\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  243 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasHttp</span> then <span class="nottickedoff">&quot;    \&quot;net/http\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  244 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasNetUrl</span> then <span class="nottickedoff">&quot;    \&quot;net/url\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  245 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasNet</span> then <span class="nottickedoff">&quot;    \&quot;net\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  246 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasSort</span> then <span class="nottickedoff">&quot;    \&quot;sort\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  247 </span><span class="spaces">        </span><span class="istickedoff">if hasMd5 then &quot;    \&quot;crypto/md5\&quot;&quot; else &quot;&quot;</span>
<span class="lineno">  248 </span><span class="spaces">        </span><span class="istickedoff">, if <span class="tickonlyfalse">hasSha1</span> then <span class="nottickedoff">&quot;    \&quot;crypto/sha1\&quot;&quot;</span> else &quot;&quot;</span>
<span class="lineno">  249 </span><span class="spaces">        </span><span class="istickedoff">, if <span class="tickonlyfalse">hasSha256</span> then <span class="nottickedoff">&quot;    \&quot;crypto/sha256\&quot;&quot;</span> else &quot;&quot;</span>
<span class="lineno">  250 </span><span class="spaces">        </span><span class="istickedoff">, if <span class="tickonlyfalse">hasSha512</span> then <span class="nottickedoff">&quot;    \&quot;crypto/sha512\&quot;&quot;</span> else &quot;&quot;</span>
<span class="lineno">  251 </span><span class="spaces">        </span><span class="istickedoff">, if <span class="tickonlyfalse">hasCrypto</span> then <span class="nottickedoff">&quot;    \&quot;crypto/aes\&quot;&quot;</span> else &quot;&quot;</span>
<span class="lineno">  252 </span><span class="spaces">        </span><span class="istickedoff">, if <span class="tickonlyfalse">hasCrypto</span> then <span class="nottickedoff">&quot;    \&quot;crypto/cipher\&quot;&quot;</span> else &quot;&quot;</span>
<span class="lineno">  253 </span><span class="spaces">        </span><span class="istickedoff">, if <span class="tickonlyfalse">hasCryptoRand</span> then <span class="nottickedoff">&quot;    \&quot;crypto/rand\&quot;&quot;</span> else &quot;&quot;</span>
<span class="lineno">  254 </span><span class="spaces">        </span><span class="istickedoff">, if hasBase64 then &quot;    \&quot;encoding/base64\&quot;&quot; else &quot;&quot;</span>
<span class="lineno">  255 </span><span class="spaces">        </span><span class="istickedoff">, if hasHex then &quot;    \&quot;encoding/hex\&quot;&quot; else &quot;&quot;,</span>
<span class="lineno">  256 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasCsv</span> then <span class="nottickedoff">&quot;    \&quot;encoding/csv\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  257 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasBytes</span> then <span class="nottickedoff">&quot;    \&quot;bytes\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  258 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasBinary</span> then <span class="nottickedoff">&quot;    \&quot;encoding/binary\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  259 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasGzip</span> then <span class="nottickedoff">&quot;    \&quot;compress/gzip\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  260 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasRing</span> then <span class="nottickedoff">&quot;    \&quot;container/ring\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  261 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasBits</span> then <span class="nottickedoff">&quot;    \&quot;math/bits\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  262 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasFnv</span> then <span class="nottickedoff">&quot;    \&quot;hash/fnv\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  263 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasSyscall</span> then <span class="nottickedoff">&quot;    \&quot;syscall\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  264 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasDatabaseSql</span> then <span class="nottickedoff">&quot;    \&quot;database/sql\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  265 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasDatabaseSql</span> then <span class="nottickedoff">&quot;    _ \&quot;github.com/mattn/go-sqlite3\&quot;&quot;</span> else &quot;&quot;,</span>
<span class="lineno">  266 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">hasTesting</span> then <span class="nottickedoff">&quot;    \&quot;testing\&quot;&quot;</span> else &quot;&quot;</span>
<span class="lineno">  267 </span><span class="spaces">      </span><span class="istickedoff">]</span>
<span class="lineno">  268 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno">  269 </span><span class="spaces">    </span><span class="istickedoff">if <span class="tickonlyfalse">null imports</span></span>
<span class="lineno">  270 </span><span class="spaces">      </span><span class="istickedoff">then <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno">  271 </span><span class="spaces">      </span><span class="istickedoff">else &quot;import (\n&quot; ++ intercalate &quot;\n&quot; imports ++ &quot;\n)\n&quot;</span></span>
<span class="lineno">  272 </span>
<span class="lineno">  273 </span>-- Enforce Go structure by wrapping stray statements into main
<span class="lineno">  274 </span>enforceGoStructure :: String -&gt; String
<span class="lineno">  275 </span><span class="decl"><span class="istickedoff">enforceGoStructure content =</span>
<span class="lineno">  276 </span><span class="spaces">  </span><span class="istickedoff">let ls = lines content</span>
<span class="lineno">  277 </span><span class="spaces">      </span><span class="istickedoff">hasMain = any (\x -&gt; &quot;func main()&quot; `isInfixOf` x) ls</span>
<span class="lineno">  278 </span><span class="spaces">      </span><span class="istickedoff">nonDecl = filter (\x -&gt; not (null (trim x)) &amp;&amp; not (any (`isPrefixOf` trim x) [&quot;package&quot;, &quot;import&quot;, &quot;func&quot;, &quot;type&quot;, &quot;var&quot;, &quot;const&quot;])) ls</span>
<span class="lineno">  279 </span><span class="spaces">  </span><span class="istickedoff">in if <span class="tickonlytrue">null nonDecl || hasMain</span> then content</span>
<span class="lineno">  280 </span><span class="spaces">     </span><span class="istickedoff">else <span class="nottickedoff">unlines $ [case filter (\x -&gt; &quot;package &quot; `isPrefixOf` x) ls of</span></span>
<span class="lineno">  281 </span><span class="spaces">                             </span><span class="istickedoff"><span class="nottickedoff">(x:_) -&gt; x</span></span>
<span class="lineno">  282 </span><span class="spaces">                             </span><span class="istickedoff"><span class="nottickedoff">[] -&gt; &quot;package main&quot;] ++</span></span>
<span class="lineno">  283 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">[&quot;&quot;, &quot;func main() {&quot;] ++ nonDecl ++ [&quot;}&quot;]</span></span></span>
<span class="lineno">  284 </span>
<span class="lineno">  285 </span>-- Utility function to trim whitespace
<span class="lineno">  286 </span>trim :: String -&gt; String
<span class="lineno">  287 </span><span class="decl"><span class="istickedoff">trim = f . f</span>
<span class="lineno">  288 </span><span class="spaces">  </span><span class="istickedoff">where f = reverse . dropWhile isSpace</span></span>
<span class="lineno">  289 </span>
<span class="lineno">  290 </span>-- Fix missing closing parenthesis for var blocks
<span class="lineno">  291 </span>fixVarBlocks :: String -&gt; String
<span class="lineno">  292 </span><span class="decl"><span class="istickedoff">fixVarBlocks content =</span>
<span class="lineno">  293 </span><span class="spaces">  </span><span class="istickedoff">let ls = lines content</span>
<span class="lineno">  294 </span><span class="spaces">      </span><span class="istickedoff">go [] inVar acc = reverse acc ++ [<span class="nottickedoff">&quot;)&quot;</span> | <span class="tickonlyfalse">inVar</span>]</span>
<span class="lineno">  295 </span><span class="spaces">      </span><span class="istickedoff">go (l:rest) inVar acc =</span>
<span class="lineno">  296 </span><span class="spaces">        </span><span class="istickedoff">let t = trim l</span>
<span class="lineno">  297 </span><span class="spaces">        </span><span class="istickedoff">in if <span class="tickonlyfalse">inVar</span></span>
<span class="lineno">  298 </span><span class="spaces">             </span><span class="istickedoff">then <span class="nottickedoff">if t == &quot;)&quot; then go rest False (l:acc)</span></span>
<span class="lineno">  299 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">else if isPrefixOf &quot;func&quot; t || isPrefixOf &quot;type&quot; t || isPrefixOf &quot;const&quot; t || isPrefixOf &quot;var&quot; t</span></span>
<span class="lineno">  300 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">then go rest False (l:acc++[&quot;)&quot;])</span></span>
<span class="lineno">  301 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">else go rest True (l:acc)</span></span>
<span class="lineno">  302 </span><span class="spaces">             </span><span class="istickedoff">else if <span class="tickonlyfalse">isPrefixOf &quot;var (&quot; t</span></span>
<span class="lineno">  303 </span><span class="spaces">                    </span><span class="istickedoff">then <span class="nottickedoff">go rest True (l:acc)</span></span>
<span class="lineno">  304 </span><span class="spaces">                    </span><span class="istickedoff">else go rest False (l:acc)</span>
<span class="lineno">  305 </span><span class="spaces">  </span><span class="istickedoff">in unlines (go ls False [])</span></span>
<span class="lineno">  306 </span>
<span class="lineno">  307 </span>-- Remove unused variable s2 declarations
<span class="lineno">  308 </span>
<span class="lineno">  309 </span>fixUnusedS2 :: String -&gt; String
<span class="lineno">  310 </span><span class="decl"><span class="istickedoff">fixUnusedS2 content =</span>
<span class="lineno">  311 </span><span class="spaces">  </span><span class="istickedoff">let ls = lines content</span>
<span class="lineno">  312 </span><span class="spaces">      </span><span class="istickedoff">declIdxs :: [Int]</span>
<span class="lineno">  313 </span><span class="spaces">      </span><span class="istickedoff">declIdxs = [ <span class="nottickedoff">i</span> | (i,l) &lt;- zip [0..] ls, let t = trim l, <span class="tickonlyfalse">isPrefixOf &quot;var s2&quot; t || isInfixOf &quot;s2 :=&quot; t</span> ]</span>
<span class="lineno">  314 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">usedElsewhere i = let name = &quot;s2&quot; in any (\(j,l) -&gt; j /= i &amp;&amp; name `isInfixOf` l) (zip [0..] ls)</span></span>
<span class="lineno">  315 </span><span class="spaces">      </span><span class="istickedoff">filtered = [ l | (i,l) &lt;- zip [0..] ls, <span class="tickonlytrue">not (<span class="nottickedoff">i</span> `elem` [<span class="nottickedoff">d</span> | d &lt;- declIdxs, <span class="nottickedoff">not (usedElsewhere d)</span>])</span> ]</span>
<span class="lineno">  316 </span><span class="spaces">  </span><span class="istickedoff">in unlines filtered</span></span>
<span class="lineno">  317 </span>
<span class="lineno">  318 </span>-- Extract variable and function declarations from code
<span class="lineno">  319 </span>extractDeclarations :: String -&gt; [String]
<span class="lineno">  320 </span><span class="decl"><span class="nottickedoff">extractDeclarations content =</span>
<span class="lineno">  321 </span><span class="spaces">  </span><span class="nottickedoff">let ls = lines content</span>
<span class="lineno">  322 </span><span class="spaces">      </span><span class="nottickedoff">isVarDecl line = any (`isPrefixOf` trim line) [&quot;var &quot;, &quot;const &quot;, &quot;func &quot;]</span>
<span class="lineno">  323 </span><span class="spaces">      </span><span class="nottickedoff">decls = filter isVarDecl ls</span>
<span class="lineno">  324 </span><span class="spaces">  </span><span class="nottickedoff">in decls</span></span>
<span class="lineno">  325 </span>
<span class="lineno">  326 </span>-- Extract function calls from code
<span class="lineno">  327 </span>extractFunctionCalls :: String -&gt; [String]
<span class="lineno">  328 </span><span class="decl"><span class="nottickedoff">extractFunctionCalls content =</span>
<span class="lineno">  329 </span><span class="spaces">  </span><span class="nottickedoff">let ls = lines content</span>
<span class="lineno">  330 </span><span class="spaces">      </span><span class="nottickedoff">calls = filter isFunctionCall ls</span>
<span class="lineno">  331 </span><span class="spaces">  </span><span class="nottickedoff">in calls</span></span>
<span class="lineno">  332 </span>
<span class="lineno">  333 </span>-- Build type environment from declarations
<span class="lineno">  334 </span>buildTypeEnv :: [String] -&gt; TypeEnv
<span class="lineno">  335 </span><span class="decl"><span class="nottickedoff">buildTypeEnv declarations = foldl addDeclaration emptyTypeEnv declarations</span>
<span class="lineno">  336 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  337 </span><span class="spaces">    </span><span class="nottickedoff">addDeclaration env line =</span>
<span class="lineno">  338 </span><span class="spaces">      </span><span class="nottickedoff">let t = trim line</span>
<span class="lineno">  339 </span><span class="spaces">      </span><span class="nottickedoff">in if isPrefixOf &quot;var &quot; t</span>
<span class="lineno">  340 </span><span class="spaces">         </span><span class="nottickedoff">then addVarDeclaration env t</span>
<span class="lineno">  341 </span><span class="spaces">         </span><span class="nottickedoff">else if isPrefixOf &quot;func &quot; t</span>
<span class="lineno">  342 </span><span class="spaces">              </span><span class="nottickedoff">then addFunctionDeclaration env t</span>
<span class="lineno">  343 </span><span class="spaces">              </span><span class="nottickedoff">else env</span></span>
<span class="lineno">  344 </span>
<span class="lineno">  345 </span>-- Add variable declaration to type environment
<span class="lineno">  346 </span>addVarDeclaration :: TypeEnv -&gt; String -&gt; TypeEnv
<span class="lineno">  347 </span><span class="decl"><span class="nottickedoff">addVarDeclaration env line =</span>
<span class="lineno">  348 </span><span class="spaces">  </span><span class="nottickedoff">let withoutVar = drop 3 (trim line)</span>
<span class="lineno">  349 </span><span class="spaces">      </span><span class="nottickedoff">(varName, varType) = break (\c -&gt; c == ' ' || c == '=') withoutVar</span>
<span class="lineno">  350 </span><span class="spaces">      </span><span class="nottickedoff">varType' = trim $ dropWhile (\c -&gt; c == ' ' || c == '=') varType</span>
<span class="lineno">  351 </span><span class="spaces">      </span><span class="nottickedoff">inferredType = inferVarType varType'</span>
<span class="lineno">  352 </span><span class="spaces">  </span><span class="nottickedoff">in env { varTypes = (varName, inferredType) : varTypes env }</span></span>
<span class="lineno">  353 </span>
<span class="lineno">  354 </span>-- Add function declaration to type environment
<span class="lineno">  355 </span>addFunctionDeclaration :: TypeEnv -&gt; String -&gt; TypeEnv
<span class="lineno">  356 </span><span class="decl"><span class="nottickedoff">addFunctionDeclaration env line =</span>
<span class="lineno">  357 </span><span class="spaces">  </span><span class="nottickedoff">-- Skip method declarations (functions with receivers)</span>
<span class="lineno">  358 </span><span class="spaces">  </span><span class="nottickedoff">if isMethodDeclaration line</span>
<span class="lineno">  359 </span><span class="spaces">    </span><span class="nottickedoff">then env</span>
<span class="lineno">  360 </span><span class="spaces">    </span><span class="nottickedoff">else let withoutFunc = drop 4 (trim line)</span>
<span class="lineno">  361 </span><span class="spaces">             </span><span class="nottickedoff">(funcName, rest) = break (\c -&gt; c == ' ' || c == '(') withoutFunc</span>
<span class="lineno">  362 </span><span class="spaces">             </span><span class="nottickedoff">paramsAndReturn = dropWhile (\c -&gt; c == ' ' || c == '(') rest</span>
<span class="lineno">  363 </span><span class="spaces">             </span><span class="nottickedoff">(params, returnType) = break (== ')') paramsAndReturn</span>
<span class="lineno">  364 </span><span class="spaces">             </span><span class="nottickedoff">paramTypes = map inferVarType $ splitByComma params</span>
<span class="lineno">  365 </span><span class="spaces">             </span><span class="nottickedoff">returnType' = if &quot;) &quot; `isPrefixOf` (drop 1 returnType)</span>
<span class="lineno">  366 </span><span class="spaces">                           </span><span class="nottickedoff">then inferVarType $ trim $ drop 2 returnType</span>
<span class="lineno">  367 </span><span class="spaces">                           </span><span class="nottickedoff">else VoidType</span>
<span class="lineno">  368 </span><span class="spaces">         </span><span class="nottickedoff">in env { functionTypes = (funcName, (paramTypes, returnType')) : functionTypes env }</span></span>
<span class="lineno">  369 </span>
<span class="lineno">  370 </span>-- Infer type from variable declaration string
<span class="lineno">  371 </span>inferVarType :: String -&gt; Type
<span class="lineno">  372 </span><span class="decl"><span class="nottickedoff">inferVarType typeStr</span>
<span class="lineno">  373 </span><span class="spaces">  </span><span class="nottickedoff">| &quot;int&quot; `isPrefixOf` typeStr = IntType</span>
<span class="lineno">  374 </span><span class="spaces">  </span><span class="nottickedoff">| &quot;string&quot; `isPrefixOf` typeStr = StringType</span>
<span class="lineno">  375 </span><span class="spaces">  </span><span class="nottickedoff">| &quot;bool&quot; `isPrefixOf` typeStr = BoolType</span>
<span class="lineno">  376 </span><span class="spaces">  </span><span class="nottickedoff">| &quot;float&quot; `isPrefixOf` typeStr = FloatType</span>
<span class="lineno">  377 </span><span class="spaces">  </span><span class="nottickedoff">| otherwise = VoidType</span></span>
<span class="lineno">  378 </span>
<span class="lineno">  379 </span>-- Split string by comma
<span class="lineno">  380 </span>splitByComma :: String -&gt; [String]
<span class="lineno">  381 </span><span class="decl"><span class="nottickedoff">splitByComma s = map trim $ splitOn ',' s</span>
<span class="lineno">  382 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  383 </span><span class="spaces">    </span><span class="nottickedoff">splitOn _ [] = []</span>
<span class="lineno">  384 </span><span class="spaces">    </span><span class="nottickedoff">splitOn delimiter str =</span>
<span class="lineno">  385 </span><span class="spaces">      </span><span class="nottickedoff">let (token, rest) = break (== delimiter) str</span>
<span class="lineno">  386 </span><span class="spaces">      </span><span class="nottickedoff">in token : splitOn delimiter (drop 1 rest)</span></span>
<span class="lineno">  387 </span>
<span class="lineno">  388 </span>-- Check for type errors in declarations and calls
<span class="lineno">  389 </span>checkTypeError :: TypeEnv -&gt; String -&gt; Bool
<span class="lineno">  390 </span><span class="decl"><span class="nottickedoff">checkTypeError env line =</span>
<span class="lineno">  391 </span><span class="spaces">  </span><span class="nottickedoff">let t = trim line</span>
<span class="lineno">  392 </span><span class="spaces">  </span><span class="nottickedoff">in if isPrefixOf &quot;var &quot; t || isPrefixOf &quot;const &quot; t</span>
<span class="lineno">  393 </span><span class="spaces">     </span><span class="nottickedoff">then checkVarDeclaration env t</span>
<span class="lineno">  394 </span><span class="spaces">     </span><span class="nottickedoff">else if isFunctionCall t</span>
<span class="lineno">  395 </span><span class="spaces">          </span><span class="nottickedoff">then checkFunctionCall env t</span>
<span class="lineno">  396 </span><span class="spaces">          </span><span class="nottickedoff">else False</span></span>
<span class="lineno">  397 </span>
<span class="lineno">  398 </span>-- Check variable declaration type consistency
<span class="lineno">  399 </span>checkVarDeclaration :: TypeEnv -&gt; String -&gt; Bool
<span class="lineno">  400 </span><span class="decl"><span class="nottickedoff">checkVarDeclaration env line =</span>
<span class="lineno">  401 </span><span class="spaces">  </span><span class="nottickedoff">let withoutVar = drop 3 (trim line)</span>
<span class="lineno">  402 </span><span class="spaces">      </span><span class="nottickedoff">(varName, rest) = break (\c -&gt; c == ' ' || c == '=') withoutVar</span>
<span class="lineno">  403 </span><span class="spaces">      </span><span class="nottickedoff">varType = trim $ dropWhile (\c -&gt; c == ' ' || c == '=') rest</span>
<span class="lineno">  404 </span><span class="spaces">  </span><span class="nottickedoff">in case lookup varName (varTypes env) of</span>
<span class="lineno">  405 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; False</span>
<span class="lineno">  406 </span><span class="spaces">    </span><span class="nottickedoff">Just declaredType -&gt;</span>
<span class="lineno">  407 </span><span class="spaces">      </span><span class="nottickedoff">let inferredType = inferVarType varType</span>
<span class="lineno">  408 </span><span class="spaces">      </span><span class="nottickedoff">in declaredType == inferredType</span></span>
<span class="lineno">  409 </span>
<span class="lineno">  410 </span>-- Check function call type consistency
<span class="lineno">  411 </span>checkFunctionCall :: TypeEnv -&gt; String -&gt; Bool
<span class="lineno">  412 </span><span class="decl"><span class="nottickedoff">checkFunctionCall env line =</span>
<span class="lineno">  413 </span><span class="spaces">  </span><span class="nottickedoff">let callPart = if &quot;=&quot; `isInfixOf` line then trim $ dropWhile (/= '=') line else line</span>
<span class="lineno">  414 </span><span class="spaces">      </span><span class="nottickedoff">(funcName, rest) = span (/= '(') (trim callPart)</span>
<span class="lineno">  415 </span><span class="spaces">      </span><span class="nottickedoff">argsStr = takeWhile (/= ')') $ drop 1 rest</span>
<span class="lineno">  416 </span><span class="spaces">      </span><span class="nottickedoff">args = splitByComma argsStr</span>
<span class="lineno">  417 </span><span class="spaces">      </span><span class="nottickedoff">argTypes = map inferVarType args</span>
<span class="lineno">  418 </span><span class="spaces">  </span><span class="nottickedoff">in case lookup funcName (functionTypes env) of</span>
<span class="lineno">  419 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; True  -- Function not found in environment, assume it's imported or built-in</span>
<span class="lineno">  420 </span><span class="spaces">    </span><span class="nottickedoff">Just (paramTypes, _) -&gt;</span>
<span class="lineno">  421 </span><span class="spaces">      </span><span class="nottickedoff">length argTypes == length paramTypes &amp;&amp;</span>
<span class="lineno">  422 </span><span class="spaces">      </span><span class="nottickedoff">and (zipWith (==) argTypes paramTypes)</span></span>

</pre>
</body>
</html>
