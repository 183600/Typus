<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    2 </span>module Ownership
<span class="lineno">    3 </span>  ( -- 数据模型
<span class="lineno">    4 </span>    OwnershipType(..)
<span class="lineno">    5 </span>  , OwnershipError(..)
<span class="lineno">    6 </span>  , OwnershipAnalyzer
<span class="lineno">    7 </span>  , newOwnershipAnalyzer
<span class="lineno">    8 </span>  , analyzeOwnership
<span class="lineno">    9 </span>  , analyzeOwnershipFile
<span class="lineno">   10 </span>  , formatOwnershipErrors
<span class="lineno">   11 </span>  , lexAll
<span class="lineno">   12 </span>  , parseProgram
<span class="lineno">   13 </span>  ) where
<span class="lineno">   14 </span>
<span class="lineno">   15 </span>
<span class="lineno">   16 </span>
<span class="lineno">   17 </span>import qualified Data.Map.Strict as Map
<span class="lineno">   18 </span>import Data.Char (isSpace, isDigit, isAlpha)
<span class="lineno">   19 </span>import Data.Maybe (isJust, mapMaybe)
<span class="lineno">   20 </span>import Data.List (intercalate)
<span class="lineno">   21 </span>import Control.Monad.State
<span class="lineno">   22 </span>
<span class="lineno">   23 </span>--------------------------------------------------------------------------------
<span class="lineno">   24 </span>-- 1) 数据类型与错误类型
<span class="lineno">   25 </span>--------------------------------------------------------------------------------
<span class="lineno">   26 </span>
<span class="lineno">   27 </span>-- 所有权类型（示意）
<span class="lineno">   28 </span>data OwnershipType
<span class="lineno">   29 </span>  = Owned String      -- 拥有所有权（变量名）
<span class="lineno">   30 </span>  | Borrowed String   -- 不可变借用（借自谁）
<span class="lineno">   31 </span>  | MutBorrowed String -- 可变借用（借自谁）
<span class="lineno">   32 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>)
<span class="lineno">   33 </span>
<span class="lineno">   34 </span>-- 所有权错误类型
<span class="lineno">   35 </span>data OwnershipError
<span class="lineno">   36 </span>  = UseAfterMove String             -- 使用已移动的值
<span class="lineno">   37 </span>  | DoubleMove String String        -- 重复移动（源→目标）
<span class="lineno">   38 </span>  | BorrowWhileMoved String         -- 在被移动后借用
<span class="lineno">   39 </span>  | MutBorrowWhileBorrowed String   -- 已有不可变借用时进行可变借用
<span class="lineno">   40 </span>  | BorrowWhileMutBorrowed String   -- 已有可变借用时进行不可变借用
<span class="lineno">   41 </span>  | MultipleMutBorrows String       -- 多个可变借用
<span class="lineno">   42 </span>  | UseWhileMutBorrowed String      -- 可变借用期间使用原值
<span class="lineno">   43 </span>  | OutOfScope String               -- 变量越界使用/未声明
<span class="lineno">   44 </span>  | BorrowError String              -- 借用错误
<span class="lineno">   45 </span>  | ParseError String               -- 解析错误
<span class="lineno">   46 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>)
<span class="lineno">   47 </span>
<span class="lineno">   48 </span>-- 分析器句柄（占位，保留外部接口）
<span class="lineno">   49 </span>newtype OwnershipAnalyzer = OwnershipAnalyzer () deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>)
<span class="lineno">   50 </span>
<span class="lineno">   51 </span>newOwnershipAnalyzer :: OwnershipAnalyzer
<span class="lineno">   52 </span><span class="decl"><span class="nottickedoff">newOwnershipAnalyzer = OwnershipAnalyzer ()</span></span>
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>--------------------------------------------------------------------------------
<span class="lineno">   55 </span>-- 2) 词法分析器（Lexer）
<span class="lineno">   56 </span>-- - 负责把源码切分为 Token
<span class="lineno">   57 </span>-- - 处理字符串/字符字面量、单行与多行注释
<span class="lineno">   58 </span>-- - 产生 Newline token，利于简单的“行终结”判断
<span class="lineno">   59 </span>-- - 忽略注释中的符号，不影响块/括号嵌套
<span class="lineno">   60 </span>--------------------------------------------------------------------------------
<span class="lineno">   61 </span>
<span class="lineno">   62 </span>data Pos = Pos { <span class="istickedoff"><span class="decl"><span class="istickedoff">pLine</span></span></span> :: !Int, <span class="nottickedoff"><span class="decl"><span class="nottickedoff">pCol</span></span></span> :: !Int } deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>data Keyword
<span class="lineno">   65 </span>  = KwVar | KwLet | KwFunc | KwReturn | KwIf | KwElse | KwFor
<span class="lineno">   66 </span>  | KwPackage | KwImport | KwType | KwStruct | KwInterface | KwConst
<span class="lineno">   67 </span>  | KwMut
<span class="lineno">   68 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>data Sym
<span class="lineno">   71 </span>  = SLBrace | SRBrace | SLParen | SRParen | SLBracket | SRBracket
<span class="lineno">   72 </span>  | SSemicolon | SComma | SColon | SAssign | SWalrus | SAmp | SDot
<span class="lineno">   73 </span>  | SNewline
<span class="lineno">   74 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">   75 </span>
<span class="lineno">   76 </span>data TokenKind
<span class="lineno">   77 </span>  = TId String
<span class="lineno">   78 </span>  | TKw Keyword
<span class="lineno">   79 </span>  | TSym Sym
<span class="lineno">   80 </span>  | TString String
<span class="lineno">   81 </span>  | TNum String
<span class="lineno">   82 </span>  | TComment String Bool  -- 内容, 是否单行注释
<span class="lineno">   83 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">   84 </span>
<span class="lineno">   85 </span>data Token = Token
<span class="lineno">   86 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">tkKind</span></span></span> :: !TokenKind
<span class="lineno">   87 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">tkPos</span></span></span>  :: !Pos
<span class="lineno">   88 </span>  } deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">   89 </span>
<span class="lineno">   90 </span>-- 关键字表
<span class="lineno">   91 </span>kwFromStr :: String -&gt; Maybe Keyword
<span class="lineno">   92 </span><span class="decl"><span class="istickedoff">kwFromStr s = case s of</span>
<span class="lineno">   93 </span><span class="spaces">  </span><span class="istickedoff">&quot;var&quot;     -&gt; Just KwVar</span>
<span class="lineno">   94 </span><span class="spaces">  </span><span class="istickedoff">&quot;let&quot;     -&gt; <span class="nottickedoff">Just KwLet</span></span>
<span class="lineno">   95 </span><span class="spaces">  </span><span class="istickedoff">&quot;func&quot;    -&gt; Just KwFunc</span>
<span class="lineno">   96 </span><span class="spaces">  </span><span class="istickedoff">&quot;return&quot;  -&gt; <span class="nottickedoff">Just KwReturn</span></span>
<span class="lineno">   97 </span><span class="spaces">  </span><span class="istickedoff">&quot;if&quot;      -&gt; <span class="nottickedoff">Just KwIf</span></span>
<span class="lineno">   98 </span><span class="spaces">  </span><span class="istickedoff">&quot;else&quot;    -&gt; <span class="nottickedoff">Just KwElse</span></span>
<span class="lineno">   99 </span><span class="spaces">  </span><span class="istickedoff">&quot;for&quot;     -&gt; <span class="nottickedoff">Just KwFor</span></span>
<span class="lineno">  100 </span><span class="spaces">  </span><span class="istickedoff">&quot;package&quot; -&gt; Just KwPackage</span>
<span class="lineno">  101 </span><span class="spaces">  </span><span class="istickedoff">&quot;import&quot;  -&gt; Just KwImport</span>
<span class="lineno">  102 </span><span class="spaces">  </span><span class="istickedoff">&quot;type&quot;    -&gt; Just KwType</span>
<span class="lineno">  103 </span><span class="spaces">  </span><span class="istickedoff">&quot;struct&quot;  -&gt; Just <span class="nottickedoff">KwStruct</span></span>
<span class="lineno">  104 </span><span class="spaces">  </span><span class="istickedoff">&quot;interface&quot;-&gt;<span class="nottickedoff">Just KwInterface</span></span>
<span class="lineno">  105 </span><span class="spaces">  </span><span class="istickedoff">&quot;const&quot;   -&gt; <span class="nottickedoff">Just KwConst</span></span>
<span class="lineno">  106 </span><span class="spaces">  </span><span class="istickedoff">&quot;mut&quot;     -&gt; <span class="nottickedoff">Just KwMut</span></span>
<span class="lineno">  107 </span><span class="spaces">  </span><span class="istickedoff">_         -&gt; Nothing</span></span>
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>-- 词法分析入口
<span class="lineno">  110 </span>lexAll :: String -&gt; [Token]
<span class="lineno">  111 </span><span class="decl"><span class="istickedoff">lexAll = go (Pos 1 1)</span>
<span class="lineno">  112 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  113 </span><span class="spaces">    </span><span class="istickedoff">go :: Pos -&gt; String -&gt; [Token]</span>
<span class="lineno">  114 </span><span class="spaces">    </span><span class="istickedoff">go _ [] = []</span>
<span class="lineno">  115 </span><span class="spaces">    </span><span class="istickedoff">go pos s@(c:cs)</span>
<span class="lineno">  116 </span><span class="spaces">      </span><span class="istickedoff">-- 换行</span>
<span class="lineno">  117 </span><span class="spaces">      </span><span class="istickedoff">| c == '\n' =</span>
<span class="lineno">  118 </span><span class="spaces">          </span><span class="istickedoff">Token (TSym SNewline) pos : go (Pos (pLine pos + 1) 1) cs</span>
<span class="lineno">  119 </span><span class="spaces">      </span><span class="istickedoff">-- 空白</span>
<span class="lineno">  120 </span><span class="spaces">      </span><span class="istickedoff">| c == ' ' || c == '\t' || c == '\r' =</span>
<span class="lineno">  121 </span><span class="spaces">          </span><span class="istickedoff">go (bump pos 1) cs</span>
<span class="lineno">  122 </span><span class="spaces">      </span><span class="istickedoff">-- 注释：//...</span>
<span class="lineno">  123 </span><span class="spaces">      </span><span class="istickedoff">| startsWith &quot;//&quot; s =</span>
<span class="lineno">  124 </span><span class="spaces">          </span><span class="istickedoff">let (comment, rest, consumedNL, newPos) = readLineComment pos s</span>
<span class="lineno">  125 </span><span class="spaces">          </span><span class="istickedoff">in Token (TComment comment True) pos : case consumedNL of</span>
<span class="lineno">  126 </span><span class="spaces">                </span><span class="istickedoff">True  -&gt; Token (TSym SNewline) newPos : go newPos rest</span>
<span class="lineno">  127 </span><span class="spaces">                </span><span class="istickedoff">False -&gt; <span class="nottickedoff">go newPos rest</span></span>
<span class="lineno">  128 </span><span class="spaces">      </span><span class="istickedoff">-- 注释：/* ... */</span>
<span class="lineno">  129 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">startsWith &quot;/*&quot; s</span> =</span>
<span class="lineno">  130 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">let (comment, rest, newPos) = readBlockComment pos s</span></span>
<span class="lineno">  131 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">in Token (TComment comment False) pos : go newPos rest</span></span>
<span class="lineno">  132 </span><span class="spaces">      </span><span class="istickedoff">-- 字符串</span>
<span class="lineno">  133 </span><span class="spaces">      </span><span class="istickedoff">| c == '&quot;' =</span>
<span class="lineno">  134 </span><span class="spaces">          </span><span class="istickedoff">let (str, rest, newPos) = readString pos cs</span>
<span class="lineno">  135 </span><span class="spaces">          </span><span class="istickedoff">in Token (TString <span class="nottickedoff">str</span>) pos : go newPos rest</span>
<span class="lineno">  136 </span><span class="spaces">      </span><span class="istickedoff">-- 字符字面量（简化处理）</span>
<span class="lineno">  137 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">c == '\''</span> =</span>
<span class="lineno">  138 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">let (ch, rest, newPos) = readChar pos cs</span></span>
<span class="lineno">  139 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">in Token (TString ch) pos : go newPos rest</span></span>
<span class="lineno">  140 </span><span class="spaces">      </span><span class="istickedoff">-- 两字符操作符 := 先于 =</span>
<span class="lineno">  141 </span><span class="spaces">      </span><span class="istickedoff">| startsWith &quot;:=&quot; s =</span>
<span class="lineno">  142 </span><span class="spaces">          </span><span class="istickedoff">Token (TSym SWalrus) pos : go (bump pos 2) (drop 2 s)</span>
<span class="lineno">  143 </span><span class="spaces">      </span><span class="istickedoff">-- 单字符符号</span>
<span class="lineno">  144 </span><span class="spaces">      </span><span class="istickedoff">| c == '=' = Token (TSym SAssign)  pos : go (bump pos 1) cs</span>
<span class="lineno">  145 </span><span class="spaces">      </span><span class="istickedoff">| c == '{' = Token (TSym SLBrace)  pos : go (bump pos 1) cs</span>
<span class="lineno">  146 </span><span class="spaces">      </span><span class="istickedoff">| c == '}' = Token (TSym SRBrace)  pos : go <span class="nottickedoff">(bump pos 1)</span> cs</span>
<span class="lineno">  147 </span><span class="spaces">      </span><span class="istickedoff">| c == '(' = Token (TSym SLParen)  pos : go (bump pos 1) cs</span>
<span class="lineno">  148 </span><span class="spaces">      </span><span class="istickedoff">| c == ')' = Token (TSym SRParen)  pos : go (bump pos 1) cs</span>
<span class="lineno">  149 </span><span class="spaces">      </span><span class="istickedoff">| c == '[' = Token (TSym SLBracket)pos : go (bump pos 1) cs</span>
<span class="lineno">  150 </span><span class="spaces">      </span><span class="istickedoff">| c == ']' = Token (TSym SRBracket)pos : go (bump pos 1) cs</span>
<span class="lineno">  151 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">c == ';'</span> = <span class="nottickedoff">Token (TSym SSemicolon)pos: go (bump pos 1) cs</span></span>
<span class="lineno">  152 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">c == ','</span> = <span class="nottickedoff">Token (TSym SComma)    pos: go (bump pos 1) cs</span></span>
<span class="lineno">  153 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">c == ':'</span> = <span class="nottickedoff">Token (TSym SColon)    pos: go (bump pos 1) cs</span></span>
<span class="lineno">  154 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">c == '&amp;'</span> = <span class="nottickedoff">Token (TSym SAmp)      pos: go (bump pos 1) cs</span></span>
<span class="lineno">  155 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">c == '.'</span> = <span class="nottickedoff">Token (TSym SDot)      pos: go (bump pos 1) cs</span></span>
<span class="lineno">  156 </span><span class="spaces">      </span><span class="istickedoff">-- 数字</span>
<span class="lineno">  157 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">isDigit c</span> =</span>
<span class="lineno">  158 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">let (num, rest) = span isNumChar s</span></span>
<span class="lineno">  159 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">newPos = bump pos (length num)</span></span>
<span class="lineno">  160 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">in Token (TNum num) pos : go newPos rest</span></span>
<span class="lineno">  161 </span><span class="spaces">      </span><span class="istickedoff">-- 标识符/关键字</span>
<span class="lineno">  162 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">isIdentStart c</span> =</span>
<span class="lineno">  163 </span><span class="spaces">          </span><span class="istickedoff">let (ident, rest) = span isIdentChar s</span>
<span class="lineno">  164 </span><span class="spaces">              </span><span class="istickedoff">newPos = bump pos (length ident)</span>
<span class="lineno">  165 </span><span class="spaces">              </span><span class="istickedoff">tk = case kwFromStr ident of</span>
<span class="lineno">  166 </span><span class="spaces">                     </span><span class="istickedoff">Just kw -&gt; TKw kw</span>
<span class="lineno">  167 </span><span class="spaces">                     </span><span class="istickedoff">Nothing -&gt; TId ident</span>
<span class="lineno">  168 </span><span class="spaces">          </span><span class="istickedoff">in Token tk pos : go newPos rest</span>
<span class="lineno">  169 </span><span class="spaces">      </span><span class="istickedoff">-- 其它（未识别的字符，直接跳过）</span>
<span class="lineno">  170 </span><span class="spaces">      </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">go (bump pos 1) cs</span></span>
<span class="lineno">  171 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  172 </span><span class="spaces">    </span><span class="istickedoff">bump (Pos l c) n = Pos l (c + n)</span>
<span class="lineno">  173 </span><span class="spaces">    </span><span class="istickedoff">startsWith pref xs = pref == take (length pref) xs</span>
<span class="lineno">  174 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  175 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">isNumChar x = isDigit x || x == '.' || x == '_'</span></span>
<span class="lineno">  176 </span><span class="spaces">    </span><span class="istickedoff">isIdentStart x = x == '_' || isAlpha x</span>
<span class="lineno">  177 </span><span class="spaces">    </span><span class="istickedoff">isIdentChar x = isIdentStart x || isDigit x</span>
<span class="lineno">  178 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  179 </span><span class="spaces">    </span><span class="istickedoff">readString :: Pos -&gt; String -&gt; (String, String, Pos)</span>
<span class="lineno">  180 </span><span class="spaces">    </span><span class="istickedoff">readString p s = goStr <span class="nottickedoff">[]</span> p s</span>
<span class="lineno">  181 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  182 </span><span class="spaces">        </span><span class="istickedoff">goStr acc posN [] = <span class="nottickedoff">(reverse acc, [], posN)</span>  -- 不完整也尽量收集</span>
<span class="lineno">  183 </span><span class="spaces">        </span><span class="istickedoff">goStr acc posN (x:xs)</span>
<span class="lineno">  184 </span><span class="spaces">          </span><span class="istickedoff">| <span class="tickonlyfalse">x == '\\'</span> = <span class="nottickedoff">case xs of</span></span>
<span class="lineno">  185 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">(y:ys) -&gt; goStr (y:'\\':acc) (bump posN 2) ys</span></span>
<span class="lineno">  186 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">[]     -&gt; (reverse ('\\':acc), [], bump posN 1)</span></span>
<span class="lineno">  187 </span><span class="spaces">          </span><span class="istickedoff">| x == '&quot;'  = (<span class="nottickedoff">reverse acc</span>, xs, bump posN 1)</span>
<span class="lineno">  188 </span><span class="spaces">          </span><span class="istickedoff">| <span class="tickonlyfalse">x == '\n'</span> = -- 字符串中断行，仍推进行列</span>
<span class="lineno">  189 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">goStr ('\n':acc) (Pos (pLine posN + 1) 1) xs</span></span>
<span class="lineno">  190 </span><span class="spaces">          </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = goStr <span class="nottickedoff">(x:acc)</span> (bump posN 1) xs</span>
<span class="lineno">  191 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  192 </span><span class="spaces">    </span><span class="istickedoff">readChar :: Pos -&gt; String -&gt; (String, String, Pos)</span>
<span class="lineno">  193 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">readChar p s = goChr [] p s</span></span>
<span class="lineno">  194 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">where</span></span>
<span class="lineno">  195 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">goChr acc posN [] = (reverse acc, [], posN)</span></span>
<span class="lineno">  196 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">goChr acc posN (x:xs)</span></span>
<span class="lineno">  197 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">| x == '\\' = case xs of</span></span>
<span class="lineno">  198 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">(y:ys) -&gt; goChr (y:'\\':acc) (bump posN 2) ys</span></span>
<span class="lineno">  199 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">[]     -&gt; (reverse ('\\':acc), [], bump posN 1)</span></span>
<span class="lineno">  200 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">| x == '\'' = (reverse acc, xs, bump posN 1)</span></span>
<span class="lineno">  201 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">| x == '\n' = goChr ('\n':acc) (Pos (pLine posN + 1) 1) xs</span></span>
<span class="lineno">  202 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">| otherwise = goChr (x:acc) (bump posN 1) xs</span></span>
<span class="lineno">  203 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  204 </span><span class="spaces">    </span><span class="istickedoff">readLineComment :: Pos -&gt; String -&gt; (String, String, Bool, Pos)</span>
<span class="lineno">  205 </span><span class="spaces">    </span><span class="istickedoff">readLineComment pos0 xs0 =</span>
<span class="lineno">  206 </span><span class="spaces">      </span><span class="istickedoff">let (_sl, rest0) = splitAt 2 xs0  -- //</span>
<span class="lineno">  207 </span><span class="spaces">          </span><span class="istickedoff">(content, rest) = break (== '\n') rest0</span>
<span class="lineno">  208 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">newPos = bump pos0 (2 + length content)</span></span>
<span class="lineno">  209 </span><span class="spaces">      </span><span class="istickedoff">in (content, dropWhile (== '\n') rest, not (null rest), if <span class="tickonlyfalse">null rest</span></span>
<span class="lineno">  210 </span><span class="spaces">            </span><span class="istickedoff">then <span class="nottickedoff">newPos</span></span>
<span class="lineno">  211 </span><span class="spaces">            </span><span class="istickedoff">else Pos (pLine pos0 + 1) 1)</span>
<span class="lineno">  212 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  213 </span><span class="spaces">    </span><span class="istickedoff">readBlockComment :: Pos -&gt; String -&gt; (String, String, Pos)</span>
<span class="lineno">  214 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">readBlockComment pos0 xs0 =</span></span>
<span class="lineno">  215 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">let (_op, rest0) = splitAt 2 xs0   -- /*</span></span>
<span class="lineno">  216 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">in goBC [] pos0 rest0</span></span>
<span class="lineno">  217 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">where</span></span>
<span class="lineno">  218 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">goBC acc posN [] = (reverse acc, [], posN)</span></span>
<span class="lineno">  219 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">goBC acc posN (x:xs)</span></span>
<span class="lineno">  220 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">| x == '*' &amp;&amp; take 1 xs == &quot;/&quot; =</span></span>
<span class="lineno">  221 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">(reverse acc, drop 2 xs, bump posN 2)</span></span>
<span class="lineno">  222 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">| x == '\n' = goBC ('\n':acc) (Pos (pLine posN + 1) 1) xs</span></span>
<span class="lineno">  223 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">| otherwise = goBC (x:acc) (bump posN 1) xs</span></span></span>
<span class="lineno">  224 </span>
<span class="lineno">  225 </span>--------------------------------------------------------------------------------
<span class="lineno">  226 </span>-- 3) 语法分析器（Parser）
<span class="lineno">  227 </span>-- - 构建一个简单 AST：语句、表达式、指令块
<span class="lineno">  228 </span>-- - 仅解析我们分析所需的子集：var/let/赋值/函数调用/&amp;借用/块/函数体
<span class="lineno">  229 </span>-- - 支持指令：//! ownership:on/off（单行）与 { //! ... }（块级）
<span class="lineno">  230 </span>--------------------------------------------------------------------------------
<span class="lineno">  231 </span>
<span class="lineno">  232 </span>type Name = String
<span class="lineno">  233 </span>
<span class="lineno">  234 </span>data AssignOp = OpAssign | OpWalrus deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  235 </span>
<span class="lineno">  236 </span>data UnaryOp = UBorrow | UMutBorrow deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  237 </span>
<span class="lineno">  238 </span>data Directive = Directive (Map.Map String String) deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  239 </span>
<span class="lineno">  240 </span>data Expr
<span class="lineno">  241 </span>  = EIdent Name Pos
<span class="lineno">  242 </span>  | ECall Name [Expr] Pos
<span class="lineno">  243 </span>  | EUnary UnaryOp Expr Pos
<span class="lineno">  244 </span>  | ELitStr String Pos
<span class="lineno">  245 </span>  | ELitNum String Pos
<span class="lineno">  246 </span>  | EUnknown [Token] Pos
<span class="lineno">  247 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  248 </span>
<span class="lineno">  249 </span>getExprPos :: Expr -&gt; Pos
<span class="lineno">  250 </span><span class="decl"><span class="nottickedoff">getExprPos e = case e of</span>
<span class="lineno">  251 </span><span class="spaces">  </span><span class="nottickedoff">EIdent _ p   -&gt; p</span>
<span class="lineno">  252 </span><span class="spaces">  </span><span class="nottickedoff">ECall _ _ p  -&gt; p</span>
<span class="lineno">  253 </span><span class="spaces">  </span><span class="nottickedoff">EUnary _ _ p -&gt; p</span>
<span class="lineno">  254 </span><span class="spaces">  </span><span class="nottickedoff">ELitStr _ p  -&gt; p</span>
<span class="lineno">  255 </span><span class="spaces">  </span><span class="nottickedoff">ELitNum _ p  -&gt; p</span>
<span class="lineno">  256 </span><span class="spaces">  </span><span class="nottickedoff">EUnknown _ p -&gt; p</span></span>
<span class="lineno">  257 </span>
<span class="lineno">  258 </span>data Stmt
<span class="lineno">  259 </span>  = SVarDecl Name (Maybe Expr) Pos
<span class="lineno">  260 </span>  | SLetDecl Name (Maybe Expr) Pos
<span class="lineno">  261 </span>  | SAssignStmt Name AssignOp Expr Pos
<span class="lineno">  262 </span>  | SExpr Expr Pos
<span class="lineno">  263 </span>  | SBlock [Stmt] Pos
<span class="lineno">  264 </span>  | SFunc [Stmt] Pos               -- 仅保留函数体作为块
<span class="lineno">  265 </span>  | SDirectiveLine Directive Pos   -- 单行指令（对后续生效）
<span class="lineno">  266 </span>  | SDirectiveBlock Directive [Stmt] Pos -- 块级指令（块内生效）
<span class="lineno">  267 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  268 </span>
<span class="lineno">  269 </span>data Program = Program [Stmt] deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  270 </span>
<span class="lineno">  271 </span>-- 解析入口
<span class="lineno">  272 </span>parseProgram :: [Token] -&gt; Program
<span class="lineno">  273 </span><span class="decl"><span class="istickedoff">parseProgram toks = Program (parseManyTop toks)</span></span>
<span class="lineno">  274 </span>
<span class="lineno">  275 </span>-- 跳过多余分隔符
<span class="lineno">  276 </span>skipNL :: [Token] -&gt; [Token]
<span class="lineno">  277 </span><span class="decl"><span class="istickedoff">skipNL (Token (TSym SNewline) _:xs)   = skipNL xs</span>
<span class="lineno">  278 </span><span class="spaces"></span><span class="istickedoff">skipNL (Token (TSym SSemicolon) _:xs) = <span class="nottickedoff">skipNL xs</span></span>
<span class="lineno">  279 </span><span class="spaces"></span><span class="istickedoff">skipNL xs = xs</span></span>
<span class="lineno">  280 </span>
<span class="lineno">  281 </span>
<span class="lineno">  282 </span>isSym :: Sym -&gt; Token -&gt; Bool
<span class="lineno">  283 </span><span class="decl"><span class="istickedoff">isSym s (Token (TSym s') _) = s == s'</span>
<span class="lineno">  284 </span><span class="spaces"></span><span class="istickedoff">isSym _ _ = False</span></span>
<span class="lineno">  285 </span>
<span class="lineno">  286 </span>isKw :: Keyword -&gt; Token -&gt; Bool
<span class="lineno">  287 </span><span class="decl"><span class="istickedoff">isKw k (Token (TKw k') _) = k == k'</span>
<span class="lineno">  288 </span><span class="spaces"></span><span class="istickedoff">isKw _ _ = False</span></span>
<span class="lineno">  289 </span>
<span class="lineno">  290 </span>tokId :: Token -&gt; Maybe (String, Pos)
<span class="lineno">  291 </span><span class="decl"><span class="istickedoff">tokId (Token (TId s) p) = Just (s, <span class="nottickedoff">p</span>)</span>
<span class="lineno">  292 </span><span class="spaces"></span><span class="istickedoff">tokId _ = Nothing</span></span>
<span class="lineno">  293 </span>
<span class="lineno">  294 </span>
<span class="lineno">  295 </span>tokComment :: Token -&gt; Maybe (String, Bool, Pos)
<span class="lineno">  296 </span><span class="decl"><span class="istickedoff">tokComment (Token (TComment s isLine) p) = Just (s, isLine, <span class="nottickedoff">p</span>)</span>
<span class="lineno">  297 </span><span class="spaces"></span><span class="istickedoff">tokComment _ = Nothing</span></span>
<span class="lineno">  298 </span>
<span class="lineno">  299 </span>-- 解析若干顶层语句，直到 EOF
<span class="lineno">  300 </span>parseManyTop :: [Token] -&gt; [Stmt]
<span class="lineno">  301 </span><span class="decl"><span class="istickedoff">parseManyTop = go 0</span>
<span class="lineno">  302 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  303 </span><span class="spaces">    </span><span class="istickedoff">go :: Int -&gt; [Token] -&gt; [Stmt]</span>
<span class="lineno">  304 </span><span class="spaces">    </span><span class="istickedoff">go depth xs = case skipNL xs of</span>
<span class="lineno">  305 </span><span class="spaces">      </span><span class="istickedoff">[] -&gt; []</span>
<span class="lineno">  306 </span><span class="spaces">      </span><span class="istickedoff">ts -&gt;</span>
<span class="lineno">  307 </span><span class="spaces">        </span><span class="istickedoff">if depth &gt; 1000  -- 防止无限递归</span>
<span class="lineno">  308 </span><span class="spaces">        </span><span class="istickedoff">then []</span>
<span class="lineno">  309 </span><span class="spaces">        </span><span class="istickedoff">else let (st, rest) = parseStmt ts</span>
<span class="lineno">  310 </span><span class="spaces">             </span><span class="istickedoff">in st : go (depth + 1) rest</span></span>
<span class="lineno">  311 </span>
<span class="lineno">  312 </span>-- 解析一般语句
<span class="lineno">  313 </span>parseStmt :: [Token] -&gt; (Stmt, [Token])
<span class="lineno">  314 </span><span class="decl"><span class="istickedoff">parseStmt xs0 =</span>
<span class="lineno">  315 </span><span class="spaces">  </span><span class="istickedoff">let xs = skipNL xs0</span>
<span class="lineno">  316 </span><span class="spaces">  </span><span class="istickedoff">in case xs of</span>
<span class="lineno">  317 </span><span class="spaces">    </span><span class="istickedoff">-- 单行指令：//! ...</span>
<span class="lineno">  318 </span><span class="spaces">    </span><span class="istickedoff">(t:rest)</span>
<span class="lineno">  319 </span><span class="spaces">      </span><span class="istickedoff">| Just (cmt, True, p) &lt;- tokComment t</span>
<span class="lineno">  320 </span><span class="spaces">      </span><span class="istickedoff">, <span class="tickonlytrue">isDirectiveText cmt</span> -&gt;</span>
<span class="lineno">  321 </span><span class="spaces">          </span><span class="istickedoff">let dir = parseDirectiveText cmt</span>
<span class="lineno">  322 </span><span class="spaces">          </span><span class="istickedoff">in (SDirectiveLine dir <span class="nottickedoff">p</span>, rest)</span>
<span class="lineno">  323 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  324 </span><span class="spaces">    </span><span class="istickedoff">-- 块：{ ... }，并支持块级指令 { //! ... statements }</span>
<span class="lineno">  325 </span><span class="spaces">    </span><span class="istickedoff">(Token (TSym SLBrace) pOpen : rest) -&gt;</span>
<span class="lineno">  326 </span><span class="spaces">      </span><span class="istickedoff">let (maybeDir, afterDir) = parseOptionalLeadingDirective rest</span>
<span class="lineno">  327 </span><span class="spaces">          </span><span class="istickedoff">(body, rest') = parseBlockBody afterDir</span>
<span class="lineno">  328 </span><span class="spaces">      </span><span class="istickedoff">in case maybeDir of</span>
<span class="lineno">  329 </span><span class="spaces">          </span><span class="istickedoff">Just dir -&gt; <span class="nottickedoff">(SDirectiveBlock dir body pOpen, rest')</span></span>
<span class="lineno">  330 </span><span class="spaces">          </span><span class="istickedoff">Nothing  -&gt; (SBlock body <span class="nottickedoff">pOpen</span>, rest')</span>
<span class="lineno">  331 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  332 </span><span class="spaces">    </span><span class="istickedoff">-- 函数：func ... { ... } 仅提取函数体</span>
<span class="lineno">  333 </span><span class="spaces">    </span><span class="istickedoff">(t:rest) | isKw KwFunc t -&gt;</span>
<span class="lineno">  334 </span><span class="spaces">      </span><span class="istickedoff">let (_, afterSig) = consumeUntilLBrace rest</span>
<span class="lineno">  335 </span><span class="spaces">          </span><span class="istickedoff">-- 现在 afterSig 是以 { 开头，交给块解析</span>
<span class="lineno">  336 </span><span class="spaces">          </span><span class="istickedoff">(blockStmt, rest') = case afterSig of</span>
<span class="lineno">  337 </span><span class="spaces">            </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">(SBlock [] (Pos 0 0), [])</span></span>
<span class="lineno">  338 </span><span class="spaces">            </span><span class="istickedoff">(t':rest'') -&gt; parseStmt (t' : rest'')</span>
<span class="lineno">  339 </span><span class="spaces">      </span><span class="istickedoff">in case blockStmt of</span>
<span class="lineno">  340 </span><span class="spaces">         </span><span class="istickedoff">SBlock body p -&gt; (SFunc body <span class="nottickedoff">p</span>, rest')</span>
<span class="lineno">  341 </span><span class="spaces">         </span><span class="istickedoff">SDirectiveBlock dir body p -&gt; <span class="nottickedoff">(SFunc [SDirectiveBlock dir body p] p, rest')</span> -- 较少见，但保留</span>
<span class="lineno">  342 </span><span class="spaces">         </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">(blockStmt, rest')</span> -- 回退</span>
<span class="lineno">  343 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  344 </span><span class="spaces">    </span><span class="istickedoff">-- var name [type] [= expr]</span>
<span class="lineno">  345 </span><span class="spaces">    </span><span class="istickedoff">(t1:t2:rest)</span>
<span class="lineno">  346 </span><span class="spaces">      </span><span class="istickedoff">| isKw KwVar t1</span>
<span class="lineno">  347 </span><span class="spaces">      </span><span class="istickedoff">, Just (name, pName) &lt;- tokId t2</span>
<span class="lineno">  348 </span><span class="spaces">      </span><span class="istickedoff">-&gt;</span>
<span class="lineno">  349 </span><span class="spaces">        </span><span class="istickedoff">let (mInit, rest') = parseVarDeclWithOptionalType rest</span>
<span class="lineno">  350 </span><span class="spaces">        </span><span class="istickedoff">in (SVarDecl name mInit <span class="nottickedoff">pName</span>, rest')</span>
<span class="lineno">  351 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  352 </span><span class="spaces">    </span><span class="istickedoff">-- const name [type] [= expr]</span>
<span class="lineno">  353 </span><span class="spaces">    </span><span class="istickedoff">(t1:t2:rest)</span>
<span class="lineno">  354 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">isKw KwConst t1</span></span>
<span class="lineno">  355 </span><span class="spaces">      </span><span class="istickedoff">, Just (name, pName) &lt;- <span class="nottickedoff">tokId t2</span></span>
<span class="lineno">  356 </span><span class="spaces">      </span><span class="istickedoff">-&gt;</span>
<span class="lineno">  357 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">let (mInit, rest') = parseVarDeclWithOptionalType rest</span></span>
<span class="lineno">  358 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">in (SVarDecl name mInit pName, rest')</span>  -- Treat const same as var for ownership analysis</span>
<span class="lineno">  359 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  360 </span><span class="spaces">    </span><span class="istickedoff">-- let name [= expr]</span>
<span class="lineno">  361 </span><span class="spaces">    </span><span class="istickedoff">(t1:t2:rest)</span>
<span class="lineno">  362 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">isKw KwLet t1</span></span>
<span class="lineno">  363 </span><span class="spaces">      </span><span class="istickedoff">, Just (name, pName) &lt;- <span class="nottickedoff">tokId t2</span></span>
<span class="lineno">  364 </span><span class="spaces">      </span><span class="istickedoff">-&gt;</span>
<span class="lineno">  365 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">let (mInit, rest') = parseOptionalInit rest</span></span>
<span class="lineno">  366 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">in (SLetDecl name mInit pName, rest')</span></span>
<span class="lineno">  367 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  368 </span><span class="spaces">    </span><span class="istickedoff">-- 赋值：name := expr 或 name = expr</span>
<span class="lineno">  369 </span><span class="spaces">    </span><span class="istickedoff">(t1:t2:rest)</span>
<span class="lineno">  370 </span><span class="spaces">      </span><span class="istickedoff">| Just (name, pName) &lt;- tokId t1</span>
<span class="lineno">  371 </span><span class="spaces">      </span><span class="istickedoff">, Token (TSym SWalrus) _ &lt;- t2</span>
<span class="lineno">  372 </span><span class="spaces">      </span><span class="istickedoff">-&gt;</span>
<span class="lineno">  373 </span><span class="spaces">        </span><span class="istickedoff">let (rhs, rest') = parseExprUntilEnd rest</span>
<span class="lineno">  374 </span><span class="spaces">        </span><span class="istickedoff">in (SAssignStmt name OpWalrus rhs <span class="nottickedoff">pName</span>, rest')</span>
<span class="lineno">  375 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  376 </span><span class="spaces">    </span><span class="istickedoff">(t1:t2:rest)</span>
<span class="lineno">  377 </span><span class="spaces">      </span><span class="istickedoff">| Just (name, pName) &lt;- tokId t1</span>
<span class="lineno">  378 </span><span class="spaces">      </span><span class="istickedoff">, Token (TSym SAssign) _ &lt;- t2</span>
<span class="lineno">  379 </span><span class="spaces">      </span><span class="istickedoff">-&gt;</span>
<span class="lineno">  380 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">let (rhs, rest') = parseExprUntilEnd rest</span></span>
<span class="lineno">  381 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">in (SAssignStmt name OpAssign rhs pName, rest')</span></span>
<span class="lineno">  382 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  383 </span><span class="spaces">    </span><span class="istickedoff">-- 其它：表达式语句</span>
<span class="lineno">  384 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  385 </span><span class="spaces">      </span><span class="istickedoff">let (e, rest) = parseExprUntilEnd xs</span>
<span class="lineno">  386 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">p = getExprPos e</span></span>
<span class="lineno">  387 </span><span class="spaces">      </span><span class="istickedoff">in (SExpr e <span class="nottickedoff">p</span>, rest)</span></span>
<span class="lineno">  388 </span>
<span class="lineno">  389 </span>-- 解析块体直到匹配的 }
<span class="lineno">  390 </span>parseBlockBody :: [Token] -&gt; ([Stmt], [Token])
<span class="lineno">  391 </span><span class="decl"><span class="istickedoff">parseBlockBody xs = go [] xs 0</span>
<span class="lineno">  392 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  393 </span><span class="spaces">    </span><span class="istickedoff">go :: [Stmt] -&gt; [Token] -&gt; Int -&gt; ([Stmt], [Token])</span>
<span class="lineno">  394 </span><span class="spaces">    </span><span class="istickedoff">go acc ts depth = case skipNL ts of</span>
<span class="lineno">  395 </span><span class="spaces">      </span><span class="istickedoff">(t:rest) | isSym SRBrace t -&gt; (reverse acc, rest)</span>
<span class="lineno">  396 </span><span class="spaces">      </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">(reverse acc, [])</span> -- 容忍缺失</span>
<span class="lineno">  397 </span><span class="spaces">      </span><span class="istickedoff">ts' -&gt;</span>
<span class="lineno">  398 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">depth &gt; 1000</span>  -- 防止无限递归</span>
<span class="lineno">  399 </span><span class="spaces">        </span><span class="istickedoff">then <span class="nottickedoff">(reverse acc, ts')</span></span>
<span class="lineno">  400 </span><span class="spaces">        </span><span class="istickedoff">else let (st, rest') = parseStmt ts'</span>
<span class="lineno">  401 </span><span class="spaces">             </span><span class="istickedoff">in go (st:acc) rest' (depth + 1)</span></span>
<span class="lineno">  402 </span>
<span class="lineno">  403 </span>-- 函数签名部分跳过直到 {
<span class="lineno">  404 </span>consumeUntilLBrace :: [Token] -&gt; ([Token], [Token])
<span class="lineno">  405 </span><span class="decl"><span class="istickedoff">consumeUntilLBrace xs = go <span class="nottickedoff">[]</span> xs</span>
<span class="lineno">  406 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  407 </span><span class="spaces">    </span><span class="istickedoff">go acc (t:rest)</span>
<span class="lineno">  408 </span><span class="spaces">      </span><span class="istickedoff">| isSym SLBrace t = (<span class="nottickedoff">reverse acc</span>, t:rest)</span>
<span class="lineno">  409 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = go <span class="nottickedoff">(t:acc)</span> rest</span>
<span class="lineno">  410 </span><span class="spaces">    </span><span class="istickedoff">go acc [] = <span class="nottickedoff">(reverse acc, [])</span></span></span>
<span class="lineno">  411 </span>
<span class="lineno">  412 </span>-- 可选：块起始处的指令 { //! ... } ，指令必须紧跟在 { 之后（允许空行）
<span class="lineno">  413 </span>parseOptionalLeadingDirective :: [Token] -&gt; (Maybe Directive, [Token])
<span class="lineno">  414 </span><span class="decl"><span class="istickedoff">parseOptionalLeadingDirective xs0 =</span>
<span class="lineno">  415 </span><span class="spaces">  </span><span class="istickedoff">let xs = skipNL xs0</span>
<span class="lineno">  416 </span><span class="spaces">  </span><span class="istickedoff">in case xs of</span>
<span class="lineno">  417 </span><span class="spaces">     </span><span class="istickedoff">(t:rest)</span>
<span class="lineno">  418 </span><span class="spaces">       </span><span class="istickedoff">| Just (cmt, True, _) &lt;- tokComment t</span>
<span class="lineno">  419 </span><span class="spaces">       </span><span class="istickedoff">, <span class="nottickedoff">isDirectiveText cmt</span> -&gt; <span class="nottickedoff">(Just (parseDirectiveText cmt), rest)</span></span>
<span class="lineno">  420 </span><span class="spaces">     </span><span class="istickedoff">_ -&gt; (Nothing, xs0)</span></span>
<span class="lineno">  421 </span>
<span class="lineno">  422 </span>-- 解析 [= expr]，允许没有初始化
<span class="lineno">  423 </span>parseOptionalInit :: [Token] -&gt; (Maybe Expr, [Token])
<span class="lineno">  424 </span><span class="decl"><span class="nottickedoff">parseOptionalInit xs0 =</span>
<span class="lineno">  425 </span><span class="spaces">  </span><span class="nottickedoff">let xs = skipNL xs0</span>
<span class="lineno">  426 </span><span class="spaces">  </span><span class="nottickedoff">in case xs of</span>
<span class="lineno">  427 </span><span class="spaces">      </span><span class="nottickedoff">(Token (TSym SAssign) _ : rest) -&gt;</span>
<span class="lineno">  428 </span><span class="spaces">        </span><span class="nottickedoff">let (e, rest') = parseExprUntilEnd rest</span>
<span class="lineno">  429 </span><span class="spaces">        </span><span class="nottickedoff">in (Just e, rest')</span>
<span class="lineno">  430 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; (Nothing, xs0)</span></span>
<span class="lineno">  431 </span>
<span class="lineno">  432 </span>-- 解析 var 声明，支持可选的类型注释：var name [type] [= expr]
<span class="lineno">  433 </span>parseVarDeclWithOptionalType :: [Token] -&gt; (Maybe Expr, [Token])
<span class="lineno">  434 </span><span class="decl"><span class="istickedoff">parseVarDeclWithOptionalType xs0 =</span>
<span class="lineno">  435 </span><span class="spaces">  </span><span class="istickedoff">let xs = skipNL xs0</span>
<span class="lineno">  436 </span><span class="spaces">  </span><span class="istickedoff">in case xs of</span>
<span class="lineno">  437 </span><span class="spaces">      </span><span class="istickedoff">-- var name = expr</span>
<span class="lineno">  438 </span><span class="spaces">      </span><span class="istickedoff">(Token (TSym SAssign) _ : rest) -&gt;</span>
<span class="lineno">  439 </span><span class="spaces">        </span><span class="istickedoff">let (e, rest') = parseExprUntilEnd rest</span>
<span class="lineno">  440 </span><span class="spaces">        </span><span class="istickedoff">in (Just e, rest')</span>
<span class="lineno">  441 </span><span class="spaces">      </span><span class="istickedoff">-- var name type [= expr]</span>
<span class="lineno">  442 </span><span class="spaces">      </span><span class="istickedoff">(t:rest) -&gt;</span>
<span class="lineno">  443 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">case t of</span></span>
<span class="lineno">  444 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">Token (TId _) _ -&gt; -- Type identifier, skip it and look for optional =</span></span>
<span class="lineno">  445 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">let restAfterType = skipNL rest</span></span>
<span class="lineno">  446 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">in case restAfterType of</span></span>
<span class="lineno">  447 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">(Token (TSym SAssign) _ : restAfterAssign) -&gt;</span></span>
<span class="lineno">  448 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">let (e, rest') = parseExprUntilEnd restAfterAssign</span></span>
<span class="lineno">  449 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">in (Just e, rest')</span></span>
<span class="lineno">  450 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; (Nothing, xs0) -- No initialization, just type declaration</span></span>
<span class="lineno">  451 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; (Nothing, xs0)</span> -- Not a type, treat as no init</span>
<span class="lineno">  452 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">(Nothing, xs0)</span></span></span> -- No type and no init
<span class="lineno">  453 </span>
<span class="lineno">  454 </span>-- 表达式：收集到行/分号/右括号/右中括号/右大括号为止（在最外层）
<span class="lineno">  455 </span>parseExprUntilEnd :: [Token] -&gt; (Expr, [Token])
<span class="lineno">  456 </span><span class="decl"><span class="istickedoff">parseExprUntilEnd xs =</span>
<span class="lineno">  457 </span><span class="spaces">  </span><span class="istickedoff">let (ts, rest) = takeExprTokens xs</span>
<span class="lineno">  458 </span><span class="spaces">  </span><span class="istickedoff">in (tokensToExpr ts, rest)</span></span>
<span class="lineno">  459 </span>
<span class="lineno">  460 </span>-- 收集表达式 token
<span class="lineno">  461 </span>takeExprTokens :: [Token] -&gt; ([Token], [Token])
<span class="lineno">  462 </span><span class="decl"><span class="istickedoff">takeExprTokens = go (0 :: Int) (0 :: Int) []</span>
<span class="lineno">  463 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  464 </span><span class="spaces">    </span><span class="istickedoff">stopTok t</span>
<span class="lineno">  465 </span><span class="spaces">      </span><span class="istickedoff">| isSym SNewline t   = True</span>
<span class="lineno">  466 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">isSym SSemicolon t</span> = <span class="nottickedoff">True</span></span>
<span class="lineno">  467 </span><span class="spaces">      </span><span class="istickedoff">| isSym SRBrace t    = True</span>
<span class="lineno">  468 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>          = False</span>
<span class="lineno">  469 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  470 </span><span class="spaces">    </span><span class="istickedoff">go :: Int -&gt; Int -&gt; [Token] -&gt; [Token] -&gt; ([Token], [Token])</span>
<span class="lineno">  471 </span><span class="spaces">    </span><span class="istickedoff">go _ _ acc [] = <span class="nottickedoff">(reverse acc, [])</span></span>
<span class="lineno">  472 </span><span class="spaces">    </span><span class="istickedoff">go paren bracket acc ts@(t:rest)</span>
<span class="lineno">  473 </span><span class="spaces">      </span><span class="istickedoff">| stopTok t &amp;&amp; paren == 0 &amp;&amp; bracket == 0</span>
<span class="lineno">  474 </span><span class="spaces">          </span><span class="istickedoff">= (reverse acc, ts)</span>
<span class="lineno">  475 </span><span class="spaces">      </span><span class="istickedoff">| isSym SLParen t    = go (paren + 1) bracket (t:acc) rest</span>
<span class="lineno">  476 </span><span class="spaces">      </span><span class="istickedoff">| isSym SRParen t    = go (max 0 (paren - 1)) bracket (t:acc) rest</span>
<span class="lineno">  477 </span><span class="spaces">      </span><span class="istickedoff">| isSym SLBracket t  = go paren (bracket + 1) (t:acc) rest</span>
<span class="lineno">  478 </span><span class="spaces">      </span><span class="istickedoff">| isSym SRBracket t  = go paren (max 0 (bracket - 1)) (t:acc) rest</span>
<span class="lineno">  479 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>          = go paren bracket (t:acc) rest</span></span>
<span class="lineno">  480 </span>
<span class="lineno">  481 </span>-- 由 token 列表构造简化表达式
<span class="lineno">  482 </span>tokensToExpr :: [Token] -&gt; Expr
<span class="lineno">  483 </span><span class="decl"><span class="istickedoff">tokensToExpr [] = EUnknown [] <span class="nottickedoff">(Pos 0 0)</span></span>
<span class="lineno">  484 </span><span class="spaces"></span><span class="istickedoff">tokensToExpr (t:ts) =</span>
<span class="lineno">  485 </span><span class="spaces">  </span><span class="istickedoff">-- &amp;mut ident</span>
<span class="lineno">  486 </span><span class="spaces">  </span><span class="istickedoff">case (t, ts) of</span>
<span class="lineno">  487 </span><span class="spaces">    </span><span class="istickedoff">(Token (TSym SAmp) p, Token (TKw KwMut) _ : Token (TId x) p2 : rest)</span>
<span class="lineno">  488 </span><span class="spaces">       </span><span class="istickedoff">| <span class="nottickedoff">null rest</span> -&gt; <span class="nottickedoff">EUnary UMutBorrow (EIdent x p2) p</span></span>
<span class="lineno">  489 </span><span class="spaces">    </span><span class="istickedoff">(Token (TSym SAmp) p, Token (TId x) p2 : rest)</span>
<span class="lineno">  490 </span><span class="spaces">       </span><span class="istickedoff">| <span class="nottickedoff">null rest</span> -&gt; <span class="nottickedoff">EUnary UBorrow (EIdent x p2) p</span></span>
<span class="lineno">  491 </span><span class="spaces">    </span><span class="istickedoff">-- ident(...) 函数调用</span>
<span class="lineno">  492 </span><span class="spaces">    </span><span class="istickedoff">(Token (TId f) p, Token (TSym SLParen) _ : more) -&gt;</span>
<span class="lineno">  493 </span><span class="spaces">      </span><span class="istickedoff">case splitTopLevelArgs more of</span>
<span class="lineno">  494 </span><span class="spaces">        </span><span class="istickedoff">Just (argsTs, afterRParen)</span>
<span class="lineno">  495 </span><span class="spaces">          </span><span class="istickedoff">| null afterRParen -&gt;</span>
<span class="lineno">  496 </span><span class="spaces">              </span><span class="istickedoff">let exprs = map tokensToExpr argsTs</span>
<span class="lineno">  497 </span><span class="spaces">              </span><span class="istickedoff">in ECall <span class="nottickedoff">f</span> exprs <span class="nottickedoff">p</span></span>
<span class="lineno">  498 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; EUnknown (t:ts) <span class="nottickedoff">p</span></span>
<span class="lineno">  499 </span><span class="spaces">    </span><span class="istickedoff">-- 标识符</span>
<span class="lineno">  500 </span><span class="spaces">    </span><span class="istickedoff">(Token (TId x) p, []) -&gt; EIdent x <span class="nottickedoff">p</span></span>
<span class="lineno">  501 </span><span class="spaces">    </span><span class="istickedoff">-- 字面量</span>
<span class="lineno">  502 </span><span class="spaces">    </span><span class="istickedoff">(Token (TString s) p, []) -&gt; ELitStr <span class="nottickedoff">s</span> <span class="nottickedoff">p</span></span>
<span class="lineno">  503 </span><span class="spaces">    </span><span class="istickedoff">(Token (TNum n) p, [])    -&gt; <span class="nottickedoff">ELitNum n p</span></span>
<span class="lineno">  504 </span><span class="spaces">    </span><span class="istickedoff">-- 其它复杂表达式（保留 token 以便后续扫描变量）</span>
<span class="lineno">  505 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; EUnknown (t:ts) <span class="nottickedoff">(tkPos t)</span></span></span>
<span class="lineno">  506 </span>
<span class="lineno">  507 </span>-- 按顶层逗号分割实参列表，要求最后一个 token 是 )
<span class="lineno">  508 </span>splitTopLevelArgs :: [Token] -&gt; Maybe ([[Token]], [Token])
<span class="lineno">  509 </span><span class="decl"><span class="istickedoff">splitTopLevelArgs ts = go [] [] (0 :: Int) (0 :: Int) ts</span>
<span class="lineno">  510 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  511 </span><span class="spaces">    </span><span class="istickedoff">go :: [[Token]] -&gt; [Token] -&gt; Int -&gt; Int -&gt; [Token] -&gt; Maybe ([[Token]], [Token])</span>
<span class="lineno">  512 </span><span class="spaces">    </span><span class="istickedoff">go acc cur paren bracket xs = case xs of</span>
<span class="lineno">  513 </span><span class="spaces">      </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  514 </span><span class="spaces">      </span><span class="istickedoff">(t:rest)</span>
<span class="lineno">  515 </span><span class="spaces">        </span><span class="istickedoff">| isSym SRParen t &amp;&amp; paren == 0 &amp;&amp; bracket == 0</span>
<span class="lineno">  516 </span><span class="spaces">            </span><span class="istickedoff">-&gt; Just (reverse (reverse cur : acc), rest)</span>
<span class="lineno">  517 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlyfalse">isSym <span class="nottickedoff">SComma</span> t &amp;&amp; <span class="nottickedoff">paren == 0 &amp;&amp; bracket == 0</span></span></span>
<span class="lineno">  518 </span><span class="spaces">            </span><span class="istickedoff">-&gt; <span class="nottickedoff">go (reverse cur : acc) [] paren bracket rest</span></span>
<span class="lineno">  519 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlyfalse">isSym <span class="nottickedoff">SLParen</span> t</span>   -&gt; <span class="nottickedoff">go acc (t:cur) (paren+1) bracket rest</span></span>
<span class="lineno">  520 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlyfalse">isSym <span class="nottickedoff">SRParen</span> t</span>   -&gt; <span class="nottickedoff">go acc (t:cur) (paren-1) bracket rest</span></span>
<span class="lineno">  521 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlyfalse">isSym <span class="nottickedoff">SLBracket</span> t</span> -&gt; <span class="nottickedoff">go acc (t:cur) paren (bracket+1) rest</span></span>
<span class="lineno">  522 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlyfalse">isSym <span class="nottickedoff">SRBracket</span> t</span> -&gt; <span class="nottickedoff">go acc (t:cur) paren (bracket-1) rest</span></span>
<span class="lineno">  523 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>         -&gt; go acc (t:cur) paren bracket rest</span></span>
<span class="lineno">  524 </span>
<span class="lineno">  525 </span>-- 指令检测与解析：支持 &quot;//! key:val[, key:val]*&quot;
<span class="lineno">  526 </span>isDirectiveText :: String -&gt; Bool
<span class="lineno">  527 </span><span class="decl"><span class="istickedoff">isDirectiveText s =</span>
<span class="lineno">  528 </span><span class="spaces">  </span><span class="istickedoff">let s' = dropWhile isSpace s</span>
<span class="lineno">  529 </span><span class="spaces">  </span><span class="istickedoff">in take 1 s' == &quot;!&quot; || <span class="nottickedoff">take 3 s' == &quot;//!&quot;</span></span></span>
<span class="lineno">  530 </span>
<span class="lineno">  531 </span>parseDirectiveText :: String -&gt; Directive
<span class="lineno">  532 </span><span class="decl"><span class="istickedoff">parseDirectiveText s =</span>
<span class="lineno">  533 </span><span class="spaces">  </span><span class="istickedoff">let s1 = dropWhile isSpace s</span>
<span class="lineno">  534 </span><span class="spaces">      </span><span class="istickedoff">s2 = dropWhile (== '!') s1</span>
<span class="lineno">  535 </span><span class="spaces">      </span><span class="istickedoff">s3 = dropWhile isSpace s2</span>
<span class="lineno">  536 </span><span class="spaces">      </span><span class="istickedoff">pairs = splitByCommaTop s3</span>
<span class="lineno">  537 </span><span class="spaces">      </span><span class="istickedoff">kvs = mapMaybe parseKV pairs</span>
<span class="lineno">  538 </span><span class="spaces">  </span><span class="istickedoff">in Directive (Map.fromList kvs)</span>
<span class="lineno">  539 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  540 </span><span class="spaces">    </span><span class="istickedoff">parseKV :: String -&gt; Maybe (String, String)</span>
<span class="lineno">  541 </span><span class="spaces">    </span><span class="istickedoff">parseKV chunk =</span>
<span class="lineno">  542 </span><span class="spaces">      </span><span class="istickedoff">let (k, v0) = break (== ':') chunk</span>
<span class="lineno">  543 </span><span class="spaces">      </span><span class="istickedoff">in case v0 of</span>
<span class="lineno">  544 </span><span class="spaces">        </span><span class="istickedoff">(':':rest) -&gt;</span>
<span class="lineno">  545 </span><span class="spaces">          </span><span class="istickedoff">let k' = trim k</span>
<span class="lineno">  546 </span><span class="spaces">              </span><span class="istickedoff">v' = map toLowerStr (trim rest)</span>
<span class="lineno">  547 </span><span class="spaces">          </span><span class="istickedoff">in if <span class="tickonlyfalse">null k'</span> then <span class="nottickedoff">Nothing</span> else Just (k', v')</span>
<span class="lineno">  548 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  549 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  550 </span><span class="spaces">    </span><span class="istickedoff">toLowerStr c = if <span class="tickonlyfalse">'A' &lt;= c &amp;&amp; c &lt;= 'Z'</span> then <span class="nottickedoff">toEnum (fromEnum c + 32)</span> else c</span>
<span class="lineno">  551 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  552 </span><span class="spaces">    </span><span class="istickedoff">splitByCommaTop :: String -&gt; [String]</span>
<span class="lineno">  553 </span><span class="spaces">    </span><span class="istickedoff">splitByCommaTop = splitOn ','</span></span>
<span class="lineno">  554 </span>
<span class="lineno">  555 </span>    {-
<span class="lineno">  556 </span>    splitOn' :: Char -&gt; String -&gt; [String]
<span class="lineno">  557 </span>    splitOn' _ &quot;&quot; = []
<span class="lineno">  558 </span>    splitOn' ch xs =
<span class="lineno">  559 </span>      let (a,b) = break (== ch) xs
<span class="lineno">  560 </span>      in case b of
<span class="lineno">  561 </span>        []     -&gt; [a]
<span class="lineno">  562 </span>        (_:ys) -&gt; a : splitOn' ch ys
<span class="lineno">  563 </span>-}
<span class="lineno">  564 </span>
<span class="lineno">  565 </span>--------------------------------------------------------------------------------
<span class="lineno">  566 </span>-- 4) 语义/所有权分析（Analyzer）
<span class="lineno">  567 </span>-- - 栈式作用域与变量遮蔽
<span class="lineno">  568 </span>-- - 借用关系：不可变/可变借用
<span class="lineno">  569 </span>-- - 指令控制（ownership:on/off）
<span class="lineno">  570 </span>--------------------------------------------------------------------------------
<span class="lineno">  571 </span>
<span class="lineno">  572 </span>-- 变量状态（栈顶为当前声明）
<span class="lineno">  573 </span>data VarState = VarState
<span class="lineno">  574 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">vsScope</span></span></span>        :: !Int
<span class="lineno">  575 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">vsMoved</span></span></span>        :: !Bool
<span class="lineno">  576 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">vsBorrowedBy</span></span></span>   :: [Name]        -- 不可变借用者
<span class="lineno">  577 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">vsMutBorrower</span></span></span>  :: Maybe Name     -- 可变借用者
<span class="lineno">  578 </span>  } deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>)
<span class="lineno">  579 </span>
<span class="lineno">  580 </span>-- 借用变量映射：借用变量 -&gt; (源变量, 是否可变借用)
<span class="lineno">  581 </span>data BorrowInfo = BorrowInfo
<span class="lineno">  582 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">biSource</span></span></span> :: !Name
<span class="lineno">  583 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">biMut</span></span></span>    :: !Bool
<span class="lineno">  584 </span>  } deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>)
<span class="lineno">  585 </span>
<span class="lineno">  586 </span>data Config = Config
<span class="lineno">  587 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">cfgOwnershipOn</span></span></span> :: !Bool
<span class="lineno">  588 </span>  } deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>)
<span class="lineno">  589 </span>
<span class="lineno">  590 </span>defaultConfig :: Config
<span class="lineno">  591 </span><span class="decl"><span class="istickedoff">defaultConfig = Config { cfgOwnershipOn = True }</span></span>
<span class="lineno">  592 </span>
<span class="lineno">  593 </span>data AState = AState
<span class="lineno">  594 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">aScope</span></span></span>      :: !Int
<span class="lineno">  595 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">aVars</span></span></span>       :: Map.Map Name [VarState]  -- 变量名 → 栈（遮蔽）
<span class="lineno">  596 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">aBorrows</span></span></span>    :: Map.Map Name BorrowInfo  -- 借用变量名 → 借用信息
<span class="lineno">  597 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">aCfgStack</span></span></span>   :: [Config]                 -- 配置栈
<span class="lineno">  598 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">aErrors</span></span></span>     :: [OwnershipError]
<span class="lineno">  599 </span>  } deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  600 </span>
<span class="lineno">  601 </span>emptyAState :: AState
<span class="lineno">  602 </span><span class="decl"><span class="istickedoff">emptyAState = AState</span>
<span class="lineno">  603 </span><span class="spaces">  </span><span class="istickedoff">{ aScope = 0</span>
<span class="lineno">  604 </span><span class="spaces">  </span><span class="istickedoff">, aVars = Map.empty</span>
<span class="lineno">  605 </span><span class="spaces">  </span><span class="istickedoff">, aBorrows = Map.empty</span>
<span class="lineno">  606 </span><span class="spaces">  </span><span class="istickedoff">, aCfgStack = [defaultConfig]</span>
<span class="lineno">  607 </span><span class="spaces">  </span><span class="istickedoff">, aErrors = []</span>
<span class="lineno">  608 </span><span class="spaces">  </span><span class="istickedoff">}</span></span>
<span class="lineno">  609 </span>
<span class="lineno">  610 </span>-- 对外入口：返回错误列表
<span class="lineno">  611 </span>analyzeOwnershipOld :: String -&gt; [OwnershipError]
<span class="lineno">  612 </span><span class="decl"><span class="istickedoff">analyzeOwnershipOld code =</span>
<span class="lineno">  613 </span><span class="spaces">  </span><span class="istickedoff">let toks = lexAll code</span>
<span class="lineno">  614 </span><span class="spaces">      </span><span class="istickedoff">ast  = parseProgram toks</span>
<span class="lineno">  615 </span><span class="spaces">  </span><span class="istickedoff">in reverse (aErrors (execState (analyzeProgram ast) emptyAState))</span></span>
<span class="lineno">  616 </span>
<span class="lineno">  617 </span>analyzeOwnershipFile :: FilePath -&gt; IO [OwnershipError]
<span class="lineno">  618 </span><span class="decl"><span class="nottickedoff">analyzeOwnershipFile fp = analyzeOwnershipOld &lt;$&gt; readFile fp</span></span>
<span class="lineno">  619 </span>
<span class="lineno">  620 </span>-- 状态操作工具
<span class="lineno">  621 </span>pushError :: OwnershipError -&gt; State AState ()
<span class="lineno">  622 </span><span class="decl"><span class="istickedoff">pushError e = do</span>
<span class="lineno">  623 </span><span class="spaces">  </span><span class="istickedoff">st &lt;- get</span>
<span class="lineno">  624 </span><span class="spaces">  </span><span class="istickedoff">let cfgOn = case aCfgStack st of</span>
<span class="lineno">  625 </span><span class="spaces">                </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">cfgOwnershipOn defaultConfig</span></span>
<span class="lineno">  626 </span><span class="spaces">                </span><span class="istickedoff">(c:_) -&gt; cfgOwnershipOn c</span>
<span class="lineno">  627 </span><span class="spaces">  </span><span class="istickedoff">if <span class="tickonlytrue">cfgOn</span> then modify (\s -&gt; s { aErrors = e : aErrors s })</span>
<span class="lineno">  628 </span><span class="spaces">           </span><span class="istickedoff">else <span class="nottickedoff">pure ()</span></span></span>
<span class="lineno">  629 </span>
<span class="lineno">  630 </span>pushScope :: State AState ()
<span class="lineno">  631 </span><span class="decl"><span class="istickedoff">pushScope = modify (\s -&gt; s { aScope = aScope s + 1 })</span></span>
<span class="lineno">  632 </span>
<span class="lineno">  633 </span>popScope :: State AState ()
<span class="lineno">  634 </span><span class="decl"><span class="istickedoff">popScope = do</span>
<span class="lineno">  635 </span><span class="spaces">  </span><span class="istickedoff">st &lt;- get</span>
<span class="lineno">  636 </span><span class="spaces">  </span><span class="istickedoff">let cur = aScope st</span>
<span class="lineno">  637 </span><span class="spaces">  </span><span class="istickedoff">-- Find variables to pop (declared at current level)</span>
<span class="lineno">  638 </span><span class="spaces">  </span><span class="istickedoff">let (_toPop, _keep) = <span class="nottickedoff">Map.mapEither (popByScope cur) (aVars st)</span></span>
<span class="lineno">  639 </span><span class="spaces">  </span><span class="istickedoff">-- Release borrow relationships for variables at current scope</span>
<span class="lineno">  640 </span><span class="spaces">  </span><span class="istickedoff">let <span class="nottickedoff">_borrowedVars = Map.keys (aBorrows st)</span></span>
<span class="lineno">  641 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">_borrowedAtCurrentScope = filter (\b -&gt; isBorrowAtCurLevel st b) _borrowedVars</span></span>
<span class="lineno">  642 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">isBorrowAtCurLevel s b = case Map.lookup b (aVars s) of</span></span>
<span class="lineno">  643 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Just (top:_) -&gt; vsScope top == aScope s</span></span>
<span class="lineno">  644 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">_            -&gt; False</span></span>
<span class="lineno">  645 </span><span class="spaces">      </span><span class="istickedoff"></span>
<span class="lineno">  646 </span><span class="spaces">      </span><span class="istickedoff">-- Create a new borrow map without entries for variables at current scope</span>
<span class="lineno">  647 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">keepBorrows = Map.filterWithKey (\b _ -&gt; not (isBorrowAtCurLevel st b)) (aBorrows st)</span></span>
<span class="lineno">  648 </span><span class="spaces">      </span><span class="istickedoff"></span>
<span class="lineno">  649 </span><span class="spaces">      </span><span class="istickedoff">-- For borrowed variables at current scope, remove their borrow relationships from source variables</span>
<span class="lineno">  650 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">updatedVars = foldl (\vars b -&gt;</span></span>
<span class="lineno">  651 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">case Map.lookup b (aBorrows st) of</span></span>
<span class="lineno">  652 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">Just (BorrowInfo src isM) -&gt;</span></span>
<span class="lineno">  653 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">Map.adjust (releaseFrom src b isM) src vars</span></span>
<span class="lineno">  654 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; vars</span></span>
<span class="lineno">  655 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">) _keep _borrowedAtCurrentScope</span></span>
<span class="lineno">  656 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  657 </span><span class="spaces">      </span><span class="istickedoff">releaseFrom :: Name -&gt; Name -&gt; Bool -&gt; [VarState] -&gt; [VarState]</span>
<span class="lineno">  658 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">releaseFrom _ _ _ [] = []</span></span>
<span class="lineno">  659 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">releaseFrom _ borrowName isM (v:vs) =</span></span>
<span class="lineno">  660 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">let v' = if isM</span></span>
<span class="lineno">  661 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">then v { vsMutBorrower = if vsMutBorrower v == Just borrowName then Nothing else vsMutBorrower v }</span></span>
<span class="lineno">  662 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">else v { vsBorrowedBy = filter (/= borrowName) (vsBorrowedBy v) }</span></span>
<span class="lineno">  663 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">in v':vs</span></span>
<span class="lineno">  664 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  665 </span><span class="spaces">  </span><span class="istickedoff">-- Update remaining variables and borrow relationships</span>
<span class="lineno">  666 </span><span class="spaces">  </span><span class="istickedoff">put st { aVars = <span class="nottickedoff">updatedVars</span>, aBorrows = <span class="nottickedoff">keepBorrows</span>, aScope = cur - 1 }</span>
<span class="lineno">  667 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  668 </span><span class="spaces">    </span><span class="istickedoff">popByScope :: Int -&gt; [VarState] -&gt; Either [VarState] [VarState]</span>
<span class="lineno">  669 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">popByScope lvl stack =</span></span>
<span class="lineno">  670 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">let (_stay, popped) = splitAt (length stack - countTop lvl stack) stack</span></span>
<span class="lineno">  671 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">in if null popped then Right stack</span></span>
<span class="lineno">  672 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">else Left popped</span></span>
<span class="lineno">  673 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  674 </span><span class="spaces">    </span><span class="istickedoff">countTop :: Int -&gt; [VarState] -&gt; Int</span>
<span class="lineno">  675 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">countTop lvl = length . takeWhile (\v -&gt; vsScope v == lvl) . reverse</span></span></span>
<span class="lineno">  676 </span>
<span class="lineno">  677 </span>-- 变量栈操作
<span class="lineno">  678 </span>lookupVarTop :: Name -&gt; State AState (Maybe VarState)
<span class="lineno">  679 </span><span class="decl"><span class="istickedoff">lookupVarTop name = do</span>
<span class="lineno">  680 </span><span class="spaces">  </span><span class="istickedoff">st &lt;- get</span>
<span class="lineno">  681 </span><span class="spaces">  </span><span class="istickedoff">pure $ do</span>
<span class="lineno">  682 </span><span class="spaces">    </span><span class="istickedoff">stack &lt;- Map.lookup name (aVars st)</span>
<span class="lineno">  683 </span><span class="spaces">    </span><span class="istickedoff">case stack of</span>
<span class="lineno">  684 </span><span class="spaces">      </span><span class="istickedoff">(v:_) -&gt; Just v</span>
<span class="lineno">  685 </span><span class="spaces">      </span><span class="istickedoff">_     -&gt; <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  686 </span>
<span class="lineno">  687 </span>updateVarTop :: Name -&gt; (VarState -&gt; VarState) -&gt; State AState ()
<span class="lineno">  688 </span><span class="decl"><span class="istickedoff">updateVarTop name f = do</span>
<span class="lineno">  689 </span><span class="spaces">  </span><span class="istickedoff">st &lt;- get</span>
<span class="lineno">  690 </span><span class="spaces">  </span><span class="istickedoff">case Map.lookup name (aVars st) of</span>
<span class="lineno">  691 </span><span class="spaces">    </span><span class="istickedoff">Just (v:vs) -&gt; put st { aVars = Map.insert name (f v : <span class="nottickedoff">vs</span>) (aVars st) }</span>
<span class="lineno">  692 </span><span class="spaces">    </span><span class="istickedoff">_           -&gt; <span class="nottickedoff">pure ()</span></span></span>
<span class="lineno">  693 </span>
<span class="lineno">  694 </span>pushVar :: Name -&gt; VarState -&gt; State AState ()
<span class="lineno">  695 </span><span class="decl"><span class="istickedoff">pushVar name v = modify $ \st -&gt;</span>
<span class="lineno">  696 </span><span class="spaces">  </span><span class="istickedoff">st { aVars = Map.insertWith <span class="nottickedoff">(++)</span> name [v] (aVars st) }</span></span>
<span class="lineno">  697 </span>
<span class="lineno">  698 </span>-- 生成唯一的借用变量名
<span class="lineno">  699 </span>-- generateBorrowVarName :: Name -&gt; Bool -&gt; State AState Name
<span class="lineno">  700 </span>-- generateBorrowVarName sourceName isMut = do
<span class="lineno">  701 </span>--   st &lt;- get
<span class="lineno">  702 </span>--   let counter = length (Map.keys (aBorrows st)) + 1
<span class="lineno">  703 </span>--   let suffix = if isMut then &quot;_mut_borrow_&quot; else &quot;_imm_borrow_&quot;
<span class="lineno">  704 </span>--   let borrowName = sourceName ++ suffix ++ show counter
<span class="lineno">  705 </span>--   pure borrowName
<span class="lineno">  706 </span>
<span class="lineno">  707 </span>-- 注册借用变量
<span class="lineno">  708 </span>registerBorrowVar :: Name -&gt; Name -&gt; Bool -&gt; State AState ()
<span class="lineno">  709 </span><span class="decl"><span class="nottickedoff">registerBorrowVar borrowName sourceName isMut = do</span>
<span class="lineno">  710 </span><span class="spaces">  </span><span class="nottickedoff">let borrowInfo = BorrowInfo { biSource = sourceName, biMut = isMut }</span>
<span class="lineno">  711 </span><span class="spaces">  </span><span class="nottickedoff">modify $ \st -&gt; st { aBorrows = Map.insert borrowName borrowInfo (aBorrows st) }</span></span>
<span class="lineno">  712 </span>
<span class="lineno">  713 </span>
<span class="lineno">  714 </span>-- 配置栈
<span class="lineno">  715 </span>withDirective :: Directive -&gt; State AState a -&gt; State AState a
<span class="lineno">  716 </span><span class="decl"><span class="nottickedoff">withDirective (Directive kv) action = do</span>
<span class="lineno">  717 </span><span class="spaces">  </span><span class="nottickedoff">let apply cfg =</span>
<span class="lineno">  718 </span><span class="spaces">        </span><span class="nottickedoff">case Map.lookup &quot;ownership&quot; kv of</span>
<span class="lineno">  719 </span><span class="spaces">          </span><span class="nottickedoff">Just &quot;on&quot;  -&gt; cfg { cfgOwnershipOn = True  }</span>
<span class="lineno">  720 </span><span class="spaces">          </span><span class="nottickedoff">Just &quot;off&quot; -&gt; cfg { cfgOwnershipOn = False }</span>
<span class="lineno">  721 </span><span class="spaces">          </span><span class="nottickedoff">_          -&gt; cfg</span>
<span class="lineno">  722 </span><span class="spaces">  </span><span class="nottickedoff">st &lt;- get</span>
<span class="lineno">  723 </span><span class="spaces">  </span><span class="nottickedoff">let cur = case aCfgStack st of</span>
<span class="lineno">  724 </span><span class="spaces">              </span><span class="nottickedoff">[] -&gt; defaultConfig</span>
<span class="lineno">  725 </span><span class="spaces">              </span><span class="nottickedoff">(c:_) -&gt; c</span>
<span class="lineno">  726 </span><span class="spaces">      </span><span class="nottickedoff">newCfg = apply cur</span>
<span class="lineno">  727 </span><span class="spaces">  </span><span class="nottickedoff">put st { aCfgStack = newCfg : aCfgStack st }</span>
<span class="lineno">  728 </span><span class="spaces">  </span><span class="nottickedoff">r &lt;- action</span>
<span class="lineno">  729 </span><span class="spaces">  </span><span class="nottickedoff">st' &lt;- get</span>
<span class="lineno">  730 </span><span class="spaces">  </span><span class="nottickedoff">put st' { aCfgStack = case aCfgStack st' of</span>
<span class="lineno">  731 </span><span class="spaces">                          </span><span class="nottickedoff">[] -&gt; []</span>
<span class="lineno">  732 </span><span class="spaces">                          </span><span class="nottickedoff">(_:cs) -&gt; cs }</span>
<span class="lineno">  733 </span><span class="spaces">  </span><span class="nottickedoff">pure r</span></span>
<span class="lineno">  734 </span>
<span class="lineno">  735 </span>applyLineDirective :: Directive -&gt; State AState ()
<span class="lineno">  736 </span><span class="decl"><span class="istickedoff">applyLineDirective (Directive kv) = modify $ \st -&gt;</span>
<span class="lineno">  737 </span><span class="spaces">  </span><span class="istickedoff">let cur = case aCfgStack st of</span>
<span class="lineno">  738 </span><span class="spaces">              </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">defaultConfig</span></span>
<span class="lineno">  739 </span><span class="spaces">              </span><span class="istickedoff">(c:_) -&gt; c</span>
<span class="lineno">  740 </span><span class="spaces">      </span><span class="istickedoff">cur' = case Map.lookup &quot;ownership&quot; kv of</span>
<span class="lineno">  741 </span><span class="spaces">               </span><span class="istickedoff">Just &quot;on&quot;  -&gt; cur { cfgOwnershipOn = True }</span>
<span class="lineno">  742 </span><span class="spaces">               </span><span class="istickedoff">Just &quot;off&quot; -&gt; <span class="nottickedoff">cur { cfgOwnershipOn = False }</span></span>
<span class="lineno">  743 </span><span class="spaces">               </span><span class="istickedoff">_          -&gt; <span class="nottickedoff">cur</span></span>
<span class="lineno">  744 </span><span class="spaces">      </span><span class="istickedoff">newStack = case aCfgStack st of</span>
<span class="lineno">  745 </span><span class="spaces">                   </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">[cur']</span></span>
<span class="lineno">  746 </span><span class="spaces">                   </span><span class="istickedoff">(_:cs) -&gt; cur':<span class="nottickedoff">cs</span></span>
<span class="lineno">  747 </span><span class="spaces">  </span><span class="istickedoff">in st { aCfgStack = newStack }</span></span>
<span class="lineno">  748 </span>
<span class="lineno">  749 </span>-- 分析入口
<span class="lineno">  750 </span>analyzeProgram :: Program -&gt; State AState ()
<span class="lineno">  751 </span><span class="decl"><span class="istickedoff">analyzeProgram (Program ss) = mapM_ analyzeStmt ss</span></span>
<span class="lineno">  752 </span>
<span class="lineno">  753 </span>analyzeStmt :: Stmt -&gt; State AState ()
<span class="lineno">  754 </span><span class="decl"><span class="istickedoff">analyzeStmt st = case st of</span>
<span class="lineno">  755 </span><span class="spaces">  </span><span class="istickedoff">SDirectiveLine dir _ -&gt; applyLineDirective dir</span>
<span class="lineno">  756 </span><span class="spaces">  </span><span class="istickedoff">SDirectiveBlock dir body _ -&gt;</span>
<span class="lineno">  757 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">withDirective dir $ do</span></span>
<span class="lineno">  758 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">pushScope</span></span>
<span class="lineno">  759 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">mapM_ analyzeStmt body</span></span>
<span class="lineno">  760 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">popScope</span></span>
<span class="lineno">  761 </span><span class="spaces">  </span><span class="istickedoff">SBlock body _ -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  762 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">pushScope</span></span>
<span class="lineno">  763 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">mapM_ analyzeStmt body</span></span>
<span class="lineno">  764 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">popScope</span></span>
<span class="lineno">  765 </span><span class="spaces">  </span><span class="istickedoff">SFunc body _ -&gt; do</span>
<span class="lineno">  766 </span><span class="spaces">    </span><span class="istickedoff">pushScope</span>
<span class="lineno">  767 </span><span class="spaces">    </span><span class="istickedoff">mapM_ analyzeStmt body</span>
<span class="lineno">  768 </span><span class="spaces">    </span><span class="istickedoff">popScope</span>
<span class="lineno">  769 </span><span class="spaces">  </span><span class="istickedoff">SVarDecl name mInit _ -&gt; do</span>
<span class="lineno">  770 </span><span class="spaces">    </span><span class="istickedoff">declareVar name</span>
<span class="lineno">  771 </span><span class="spaces">    </span><span class="istickedoff">maybe <span class="nottickedoff">(pure ())</span> analyzeExprForInit mInit</span>
<span class="lineno">  772 </span><span class="spaces">  </span><span class="istickedoff">SLetDecl name mInit _ -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  773 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">declareVar name</span></span>
<span class="lineno">  774 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">maybe (pure ()) analyzeExprForInit mInit</span></span>
<span class="lineno">  775 </span><span class="spaces">  </span><span class="istickedoff">SAssignStmt name op rhs _ -&gt; do</span>
<span class="lineno">  776 </span><span class="spaces">    </span><span class="istickedoff">-- := 新变量声明</span>
<span class="lineno">  777 </span><span class="spaces">    </span><span class="istickedoff">case op of</span>
<span class="lineno">  778 </span><span class="spaces">      </span><span class="istickedoff">OpWalrus -&gt; do</span>
<span class="lineno">  779 </span><span class="spaces">        </span><span class="istickedoff">-- 检查是否是借用表达式</span>
<span class="lineno">  780 </span><span class="spaces">        </span><span class="istickedoff">case rhs of</span>
<span class="lineno">  781 </span><span class="spaces">          </span><span class="istickedoff">EUnary UBorrow (EIdent sourceName _) _ -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  782 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">declareVar name</span></span>
<span class="lineno">  783 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- 注册借用变量</span></span>
<span class="lineno">  784 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">registerBorrowVar name sourceName False</span></span>
<span class="lineno">  785 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- 更新源变量以记录实际的借用变量名</span></span>
<span class="lineno">  786 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">updateVarTop sourceName (\vv -&gt; vv { vsBorrowedBy = name:vsBorrowedBy vv })</span></span>
<span class="lineno">  787 </span><span class="spaces">          </span><span class="istickedoff">EUnary UMutBorrow (EIdent sourceName _) _ -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  788 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">declareVar name</span></span>
<span class="lineno">  789 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- 注册借用变量</span></span>
<span class="lineno">  790 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">registerBorrowVar name sourceName True</span></span>
<span class="lineno">  791 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- 更新源变量以记录实际的借用变量名</span></span>
<span class="lineno">  792 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">updateVarTop sourceName (\vv -&gt; vv { vsMutBorrower = Just name })</span></span>
<span class="lineno">  793 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; do</span>
<span class="lineno">  794 </span><span class="spaces">            </span><span class="istickedoff">declareVar name</span>
<span class="lineno">  795 </span><span class="spaces">            </span><span class="istickedoff">analyzeAsRHS rhs</span>
<span class="lineno">  796 </span><span class="spaces">      </span><span class="istickedoff">OpAssign -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  797 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">-- For regular assignment (=), check if we're assigning from an existing variable</span></span>
<span class="lineno">  798 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">-- This should be treated as a move</span></span>
<span class="lineno">  799 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">-- First, check if the target variable exists</span></span>
<span class="lineno">  800 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">mv &lt;- lookupVarTop name</span></span>
<span class="lineno">  801 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">case mv of</span></span>
<span class="lineno">  802 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; declareVar name</span></span>
<span class="lineno">  803 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">Just _ -&gt; pure ()</span></span>
<span class="lineno">  804 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">-- Then analyze the RHS which may contain moves</span></span>
<span class="lineno">  805 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">analyzeAsRHS rhs</span></span>
<span class="lineno">  806 </span><span class="spaces">    </span><span class="istickedoff">analyzeExprForAssignment <span class="nottickedoff">name</span> rhs</span>
<span class="lineno">  807 </span><span class="spaces">  </span><span class="istickedoff">SExpr e _ -&gt; analyzeExprUse e</span></span>
<span class="lineno">  808 </span>
<span class="lineno">  809 </span>-- 声明变量（在当前作用域）
<span class="lineno">  810 </span>declareVar :: Name -&gt; State AState ()
<span class="lineno">  811 </span><span class="decl"><span class="istickedoff">declareVar n = do</span>
<span class="lineno">  812 </span><span class="spaces">  </span><span class="istickedoff">st &lt;- get</span>
<span class="lineno">  813 </span><span class="spaces">  </span><span class="istickedoff">let lvl = aScope st</span>
<span class="lineno">  814 </span><span class="spaces">  </span><span class="istickedoff">pushVar n (VarState { vsScope = lvl, vsMoved = False, vsBorrowedBy = [], vsMutBorrower = Nothing })</span></span>
<span class="lineno">  815 </span>
<span class="lineno">  816 </span>-- 分析初始化表达式
<span class="lineno">  817 </span>analyzeExprForInit :: Expr -&gt; State AState ()
<span class="lineno">  818 </span><span class="decl"><span class="istickedoff">analyzeExprForInit = analyzeAsRHS</span></span>
<span class="lineno">  819 </span>
<span class="lineno">  820 </span>-- 分析赋值右侧
<span class="lineno">  821 </span>analyzeExprForAssignment :: Name -&gt; Expr -&gt; State AState ()
<span class="lineno">  822 </span><span class="decl"><span class="istickedoff">analyzeExprForAssignment _target = analyzeAsRHS</span></span>
<span class="lineno">  823 </span>
<span class="lineno">  824 </span>-- 作为 RHS：函数实参/赋值右侧的变量一般按“移动”处理（除非是借用表达式）
<span class="lineno">  825 </span>analyzeAsRHS :: Expr -&gt; State AState ()
<span class="lineno">  826 </span><span class="decl"><span class="istickedoff">analyzeAsRHS e = case e of</span>
<span class="lineno">  827 </span><span class="spaces">  </span><span class="istickedoff">EIdent x _ -&gt; moveVar x</span>
<span class="lineno">  828 </span><span class="spaces">  </span><span class="istickedoff">EUnary UBorrow (EIdent x _) _ -&gt; <span class="nottickedoff">borrowVar False x</span></span>
<span class="lineno">  829 </span><span class="spaces">  </span><span class="istickedoff">EUnary UMutBorrow (EIdent x _) _ -&gt; <span class="nottickedoff">borrowVar True x</span></span>
<span class="lineno">  830 </span><span class="spaces">  </span><span class="istickedoff">ECall _ args _ -&gt; <span class="nottickedoff">mapM_ analyzeAsArg args</span></span>
<span class="lineno">  831 </span><span class="spaces">  </span><span class="istickedoff">EUnknown ts _  -&gt; <span class="nottickedoff">scanUnknownAsUse ts</span></span>
<span class="lineno">  832 </span><span class="spaces">  </span><span class="istickedoff">_ -&gt; pure <span class="nottickedoff">()</span></span></span> -- 字面量等不影响所有权
<span class="lineno">  833 </span>
<span class="lineno">  834 </span>-- 函数参数：非借用的标识符按“移动”处理；借用表达式按借用处理
<span class="lineno">  835 </span>analyzeAsArg :: Expr -&gt; State AState ()
<span class="lineno">  836 </span><span class="decl"><span class="nottickedoff">analyzeAsArg e = case e of</span>
<span class="lineno">  837 </span><span class="spaces">  </span><span class="nottickedoff">EUnary UBorrow (EIdent x _) _    -&gt; borrowVar False x</span>
<span class="lineno">  838 </span><span class="spaces">  </span><span class="nottickedoff">EUnary UMutBorrow (EIdent x _) _ -&gt; borrowVar True x</span>
<span class="lineno">  839 </span><span class="spaces">  </span><span class="nottickedoff">EIdent x _                       -&gt; moveVar x</span>
<span class="lineno">  840 </span><span class="spaces">  </span><span class="nottickedoff">ECall _ args _                   -&gt; mapM_ analyzeAsArg args</span>
<span class="lineno">  841 </span><span class="spaces">  </span><span class="nottickedoff">EUnknown ts _                    -&gt; scanUnknownAsUse ts</span>
<span class="lineno">  842 </span><span class="spaces">  </span><span class="nottickedoff">_                                -&gt; pure ()</span></span>
<span class="lineno">  843 </span>
<span class="lineno">  844 </span>-- 表达式用作“使用”（非移动）
<span class="lineno">  845 </span>analyzeExprUse :: Expr -&gt; State AState ()
<span class="lineno">  846 </span><span class="decl"><span class="istickedoff">analyzeExprUse e = case e of</span>
<span class="lineno">  847 </span><span class="spaces">  </span><span class="istickedoff">EIdent x _ -&gt; useVar x</span>
<span class="lineno">  848 </span><span class="spaces">  </span><span class="istickedoff">EUnary _ inner _ -&gt; <span class="nottickedoff">analyzeExprUse inner</span></span>
<span class="lineno">  849 </span><span class="spaces">  </span><span class="istickedoff">ECall _ args _ -&gt; mapM_ analyzeExprUse args</span>
<span class="lineno">  850 </span><span class="spaces">  </span><span class="istickedoff">EUnknown ts _ -&gt; scanUnknownAsUse ts</span>
<span class="lineno">  851 </span><span class="spaces">  </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">pure ()</span></span></span>
<span class="lineno">  852 </span>
<span class="lineno">  853 </span>-- 在 Unknown 表达式中扫描可能的标识符使用（保守，不做移动）
<span class="lineno">  854 </span>scanUnknownAsUse :: [Token] -&gt; State AState ()
<span class="lineno">  855 </span><span class="decl"><span class="istickedoff">scanUnknownAsUse ts = mapM_ (\x -&gt; useVar x) (collectPlainIdents ts)</span></span>
<span class="lineno">  856 </span>
<span class="lineno">  857 </span>collectPlainIdents :: [Token] -&gt; [Name]
<span class="lineno">  858 </span><span class="decl"><span class="istickedoff">collectPlainIdents = mapMaybe f</span>
<span class="lineno">  859 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  860 </span><span class="spaces">    </span><span class="istickedoff">f (Token (TId s) _) = Just s</span>
<span class="lineno">  861 </span><span class="spaces">    </span><span class="istickedoff">f _                 = Nothing</span></span>
<span class="lineno">  862 </span>
<span class="lineno">  863 </span>-- 借用
<span class="lineno">  864 </span>borrowVar :: Bool -&gt; Name -&gt; State AState ()
<span class="lineno">  865 </span><span class="decl"><span class="nottickedoff">borrowVar isMut name = do</span>
<span class="lineno">  866 </span><span class="spaces">  </span><span class="nottickedoff">m &lt;- lookupVarTop name</span>
<span class="lineno">  867 </span><span class="spaces">  </span><span class="nottickedoff">case m of</span>
<span class="lineno">  868 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; pushError (OutOfScope name)</span>
<span class="lineno">  869 </span><span class="spaces">    </span><span class="nottickedoff">Just v -&gt;</span>
<span class="lineno">  870 </span><span class="spaces">      </span><span class="nottickedoff">if vsMoved v</span>
<span class="lineno">  871 </span><span class="spaces">        </span><span class="nottickedoff">then pushError (BorrowWhileMoved name)</span>
<span class="lineno">  872 </span><span class="spaces">        </span><span class="nottickedoff">else if isMut</span>
<span class="lineno">  873 </span><span class="spaces">          </span><span class="nottickedoff">then case vsMutBorrower v of</span>
<span class="lineno">  874 </span><span class="spaces">                 </span><span class="nottickedoff">Just _ -&gt; pushError (MultipleMutBorrows name)</span>
<span class="lineno">  875 </span><span class="spaces">                 </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno">  876 </span><span class="spaces">                   </span><span class="nottickedoff">if null (vsBorrowedBy v)</span>
<span class="lineno">  877 </span><span class="spaces">                      </span><span class="nottickedoff">then do</span>
<span class="lineno">  878 </span><span class="spaces">                        </span><span class="nottickedoff">-- 使用调用者提供的借用变量名（在赋值分析中设置）</span>
<span class="lineno">  879 </span><span class="spaces">                        </span><span class="nottickedoff">updateVarTop name (\vv -&gt; vv { vsMutBorrower = Just &quot;&lt;pending&gt;&quot; })</span>
<span class="lineno">  880 </span><span class="spaces">                      </span><span class="nottickedoff">else pushError (MutBorrowWhileBorrowed name)</span>
<span class="lineno">  881 </span><span class="spaces">          </span><span class="nottickedoff">else case vsMutBorrower v of</span>
<span class="lineno">  882 </span><span class="spaces">                 </span><span class="nottickedoff">Just _ -&gt; pushError (BorrowWhileMutBorrowed name)</span>
<span class="lineno">  883 </span><span class="spaces">                 </span><span class="nottickedoff">Nothing -&gt; do</span>
<span class="lineno">  884 </span><span class="spaces">                   </span><span class="nottickedoff">-- 使用调用者提供的借用变量名（在赋值分析中设置）</span>
<span class="lineno">  885 </span><span class="spaces">                   </span><span class="nottickedoff">updateVarTop name (\vv -&gt; vv { vsBorrowedBy = &quot;&lt;pending&gt;&quot;:vsBorrowedBy vv })</span></span>
<span class="lineno">  886 </span>
<span class="lineno">  887 </span>-- 移动
<span class="lineno">  888 </span>moveVar :: Name -&gt; State AState ()
<span class="lineno">  889 </span><span class="decl"><span class="istickedoff">moveVar name = do</span>
<span class="lineno">  890 </span><span class="spaces">  </span><span class="istickedoff">mv &lt;- lookupVarTop name</span>
<span class="lineno">  891 </span><span class="spaces">  </span><span class="istickedoff">case mv of</span>
<span class="lineno">  892 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">pushError (OutOfScope name)</span></span>
<span class="lineno">  893 </span><span class="spaces">    </span><span class="istickedoff">Just v -&gt;</span>
<span class="lineno">  894 </span><span class="spaces">      </span><span class="istickedoff">if vsMoved v</span>
<span class="lineno">  895 </span><span class="spaces">        </span><span class="istickedoff">then pushError <span class="nottickedoff">(DoubleMove name name)</span></span>
<span class="lineno">  896 </span><span class="spaces">        </span><span class="istickedoff">else if <span class="tickonlyfalse">not (null (vsBorrowedBy v)) || isJust (vsMutBorrower v)</span></span>
<span class="lineno">  897 </span><span class="spaces">          </span><span class="istickedoff">then <span class="nottickedoff">pushError (BorrowWhileMoved name)</span> -- 有借用时再移动，这里统一报 BorrowWhileMoved</span>
<span class="lineno">  898 </span><span class="spaces">          </span><span class="istickedoff">else updateVarTop name (\vv -&gt; vv { vsMoved = True })</span></span>
<span class="lineno">  899 </span>
<span class="lineno">  900 </span>
<span class="lineno">  901 </span>-- 使用
<span class="lineno">  902 </span>useVar :: Name -&gt; State AState ()
<span class="lineno">  903 </span><span class="decl"><span class="istickedoff">useVar name = do</span>
<span class="lineno">  904 </span><span class="spaces">  </span><span class="istickedoff">-- First check if this is a borrow variable</span>
<span class="lineno">  905 </span><span class="spaces">  </span><span class="istickedoff">st &lt;- get</span>
<span class="lineno">  906 </span><span class="spaces">  </span><span class="istickedoff">case Map.lookup name (aBorrows st) of</span>
<span class="lineno">  907 </span><span class="spaces">    </span><span class="istickedoff">Just (BorrowInfo src isMut) -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  908 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">-- Using a borrow variable - check the source variable's borrow status</span></span>
<span class="lineno">  909 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">mv &lt;- lookupVarTop src</span></span>
<span class="lineno">  910 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">case mv of</span></span>
<span class="lineno">  911 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; pushError (OutOfScope src)</span></span>
<span class="lineno">  912 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Just v -&gt;</span></span>
<span class="lineno">  913 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">if vsMoved v</span></span>
<span class="lineno">  914 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">then pushError (BorrowWhileMoved src)</span></span>
<span class="lineno">  915 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">else if isMut</span></span>
<span class="lineno">  916 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">then case vsMutBorrower v of</span></span>
<span class="lineno">  917 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">Just borrower -&gt; if borrower == name</span></span>
<span class="lineno">  918 </span><span class="spaces">                                      </span><span class="istickedoff"><span class="nottickedoff">then pure ()  -- This is the valid mutable borrow</span></span>
<span class="lineno">  919 </span><span class="spaces">                                      </span><span class="istickedoff"><span class="nottickedoff">else pushError (MultipleMutBorrows src)</span></span>
<span class="lineno">  920 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; pushError (BorrowError src)</span></span>
<span class="lineno">  921 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">else case elem name (vsBorrowedBy v) of</span></span>
<span class="lineno">  922 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">True -&gt; pure ()  -- This is a valid immutable borrow</span></span>
<span class="lineno">  923 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">False -&gt; pushError (BorrowError src)</span></span>
<span class="lineno">  924 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; do</span>
<span class="lineno">  925 </span><span class="spaces">      </span><span class="istickedoff">-- Regular variable usage</span>
<span class="lineno">  926 </span><span class="spaces">      </span><span class="istickedoff">mv &lt;- lookupVarTop name</span>
<span class="lineno">  927 </span><span class="spaces">      </span><span class="istickedoff">case mv of</span>
<span class="lineno">  928 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; pushError (OutOfScope <span class="nottickedoff">name</span>)</span>
<span class="lineno">  929 </span><span class="spaces">        </span><span class="istickedoff">Just v -&gt;</span>
<span class="lineno">  930 </span><span class="spaces">          </span><span class="istickedoff">if <span class="tickonlytrue">vsMoved v</span></span>
<span class="lineno">  931 </span><span class="spaces">            </span><span class="istickedoff">then pushError (UseAfterMove <span class="nottickedoff">name</span>)</span>
<span class="lineno">  932 </span><span class="spaces">            </span><span class="istickedoff">else <span class="nottickedoff">case vsMutBorrower v of</span></span>
<span class="lineno">  933 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">Just _ -&gt; pushError (UseWhileMutBorrowed name)</span></span>
<span class="lineno">  934 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; pure ()</span></span></span>
<span class="lineno">  935 </span>
<span class="lineno">  936 </span>--------------------------------------------------------------------------------
<span class="lineno">  937 </span>-- 5) 工具函数
<span class="lineno">  938 </span>--------------------------------------------------------------------------------
<span class="lineno">  939 </span>
<span class="lineno">  940 </span>trim :: String -&gt; String
<span class="lineno">  941 </span><span class="decl"><span class="istickedoff">trim = dropWhile isSpace . reverse . dropWhile isSpace . reverse</span></span>
<span class="lineno">  942 </span>
<span class="lineno">  943 </span>-- 简单逗号分割（不处理引号嵌套；用于指令键值对已足够）
<span class="lineno">  944 </span>splitOn :: Char -&gt; String -&gt; [String]
<span class="lineno">  945 </span><span class="decl"><span class="istickedoff">splitOn _ &quot;&quot; = <span class="nottickedoff">[]</span></span>
<span class="lineno">  946 </span><span class="spaces"></span><span class="istickedoff">splitOn ch xs =</span>
<span class="lineno">  947 </span><span class="spaces">  </span><span class="istickedoff">let (a,b) = break (== ch) xs</span>
<span class="lineno">  948 </span><span class="spaces">  </span><span class="istickedoff">in case b of</span>
<span class="lineno">  949 </span><span class="spaces">    </span><span class="istickedoff">[]     -&gt; [a]</span>
<span class="lineno">  950 </span><span class="spaces">    </span><span class="istickedoff">(_:ys) -&gt; <span class="nottickedoff">a : splitOn ch ys</span></span></span>
<span class="lineno">  951 </span>
<span class="lineno">  952 </span>-- Main entry point for ownership analysis
<span class="lineno">  953 </span>analyzeOwnership :: String -&gt; [OwnershipError]
<span class="lineno">  954 </span><span class="decl"><span class="istickedoff">analyzeOwnership code = analyzeOwnershipOld code</span></span>
<span class="lineno">  955 </span>
<span class="lineno">  956 </span>-- Format ownership errors for display
<span class="lineno">  957 </span>formatOwnershipErrors :: [OwnershipError] -&gt; String
<span class="lineno">  958 </span><span class="decl"><span class="nottickedoff">formatOwnershipErrors = intercalate &quot;; &quot; . map formatError</span>
<span class="lineno">  959 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  960 </span><span class="spaces">    </span><span class="nottickedoff">formatError (UseAfterMove var) = &quot;Use after move: &quot; ++ var</span>
<span class="lineno">  961 </span><span class="spaces">    </span><span class="nottickedoff">formatError (DoubleMove src dest) = &quot;Double move: &quot; ++ src ++ &quot; to &quot; ++ dest</span>
<span class="lineno">  962 </span><span class="spaces">    </span><span class="nottickedoff">formatError (BorrowWhileMoved var) = &quot;Borrow while moved: &quot; ++ var</span>
<span class="lineno">  963 </span><span class="spaces">    </span><span class="nottickedoff">formatError (MutBorrowWhileBorrowed var) = &quot;Mutable borrow while borrowed: &quot; ++ var</span>
<span class="lineno">  964 </span><span class="spaces">    </span><span class="nottickedoff">formatError (BorrowWhileMutBorrowed var) = &quot;Borrow while mut borrowed: &quot; ++ var</span>
<span class="lineno">  965 </span><span class="spaces">    </span><span class="nottickedoff">formatError (MultipleMutBorrows var) = &quot;Multiple mutable borrows: &quot; ++ var</span>
<span class="lineno">  966 </span><span class="spaces">    </span><span class="nottickedoff">formatError (UseWhileMutBorrowed var) = &quot;Use while mut borrowed: &quot; ++ var</span>
<span class="lineno">  967 </span><span class="spaces">    </span><span class="nottickedoff">formatError (OutOfScope var) = &quot;Out of scope: &quot; ++ var</span>
<span class="lineno">  968 </span><span class="spaces">    </span><span class="nottickedoff">formatError (BorrowError var) = &quot;Borrow error: &quot; ++ var</span>
<span class="lineno">  969 </span><span class="spaces">    </span><span class="nottickedoff">formatError (ParseError msg) = &quot;Parse error: &quot; ++ msg</span></span>

</pre>
</body>
</html>
