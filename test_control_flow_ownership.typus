// 测试控制流分析的所有权系统
// 这个文件测试条件分支和循环中的所有权转移

func testConditionalOwnership() {
    // 测试1: 条件分支中的所有权转移
    let x = "hello"
    let y = "world"
    
    if x > y {
        // 在if分支中使用x
        println(x)
        // 在if分支中移动y
        let z = y
        println(z)
    } else {
        // 在else分支中移动x
        let w = x
        println(w)
        // 在else分支中使用y
        println(y)
    }
    
    // 这里应该检测到错误：x和y都可能在某个分支被移动
    // println(x)  // 这应该报错 - x可能在else分支被移动
    // println(y)  // 这应该报错 - y可能在if分支被移动
}

func testLoopOwnership() {
    // 测试2: 循环中的所有权模式
    let items = ["a", "b", "c"]
    let mut sum = ""
    
    for item in items {
        // 循环中借用item
        let borrowed = &item
        println(borrowed)
        
        // 在循环中移动sum - 每次迭代都会重新创建
        let temp = sum
        sum = temp + item
    }
    
    // 循环后使用sum应该是安全的
    println(sum)
}

func testNestedConditions() {
    // 测试3: 嵌套条件分支
    let a = "first"
    let b = "second"
    let c = "third"
    
    if a > b {
        if b > c {
            // 深层嵌套中的所有权转移
            let temp1 = a
            let temp2 = b
            println(temp1)
            println(temp2)
        } else {
            let temp3 = c
            println(temp3)
        }
        // 这里a和b可能已经被移动
    } else {
        // 这里a没有被移动，b也没有被移动
        println(a)
        println(b)
    }
    
    // 路径敏感分析应该能确定c始终可用
    println(c)
}

func testWhileLoopOwnership() {
    // 测试4: while循环中的所有权
    let mut counter = 0
    let data = "important"
    
    while counter < 3 {
        // 在循环中借用data
        let borrowed_data = &data
        println(borrowed_data)
        
        // 修改计数器
        counter = counter + 1
    }
    
    // 循环后data仍然可用
    println(data)
}

func testComplexControlFlow() {
    // 测试5: 复杂控制流组合
    let resource1 = "resource1"
    let resource2 = "resource2"
    let mut flag = true
    
    if flag {
        for i in [1, 2, 3] {
            if i > 1 {
                // 条件移动
                let temp = resource1
                println(temp)
                flag = false
            }
        }
    } else {
        // 另一个分支
        let temp2 = resource2
        println(temp2)
    }
    
    // 路径敏感分析应该能跟踪resource1和resource2的状态
    // 基于flag的值和循环的执行情况
}

func testBorrowInBranches() {
    // 测试6: 分支中的借用模式
    let data = "shared_data"
    let condition = true
    
    if condition {
        // 在if分支中可变借用
        let mut_ref = &mut data
        // 使用mut_ref...
    } else {
        // 在else分支中不可变借用
        let ref = &data
        // 使用ref...
    }
    
    // 两个分支都结束后，data应该可用
    println(data)
}

func testLoopBorrowPatterns() {
    // 测试7: 循环中的借用模式
    let mut collection = ["item1", "item2", "item3"]
    
    for item in collection {
        // 在循环中可变借用整个集合
        let mut_ref = &mut collection
        
        // 同时使用当前项（借用）
        let item_ref = &item
        println(item_ref)
        
        // 通过可变引用修改集合
        // 注意：这可能导致迭代器失效，应该被检测到
    }
}

// 主函数测试所有场景
func main() {
    testConditionalOwnership()
    testLoopOwnership()
    testNestedConditions()
    testWhileLoopOwnership()
    testComplexControlFlow()
    testBorrowInBranches()
    testLoopBorrowPatterns()
}